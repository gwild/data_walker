<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Walks - Compare</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 14px;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #dataPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #333;
            z-index: 100;
            width: 280px;
            max-height: calc(100vh - 240px);
            overflow-y: auto;
        }
        #controls {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 20px;
            display: grid;
            grid-template-columns: repeat(12, minmax(0, 1fr));
            /* Keep controls compact: this layout is constrained to 2 rows max. */
            grid-template-rows: auto auto;
            column-gap: 10px;
            row-gap: 6px;
            align-items: start;
            background: rgba(20, 20, 30, 0.9);
            padding: 8px 10px;
            border-radius: 12px;
            border: 1px solid #333;
            z-index: 100;
            width: calc(100vw - 24px);
            margin: 0 12px;
            overflow: visible;
            font-size: 12px;
        }
        body.fullscreen-ui-hidden #dataPanel,
        body.fullscreen-ui-hidden #controls,
        body.fullscreen-ui-hidden #legend,
        body.fullscreen-ui-hidden #statusBanner {
            display: none !important;
        }
        #statusBanner {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 120;
            background: rgba(12, 18, 34, 0.92);
            border: 1px solid #2f4d80;
            color: #9ec1ff;
            font-size: 0.85em;
            padding: 8px 12px;
            border-radius: 10px;
            max-width: min(70vw, 760px);
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        h1 {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #7af;
        }
        .group-header {
            color: #888;
            font-size: 0.75em;
            text-transform: uppercase;
            margin-top: 12px;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #333;
        }
        .subgroup-header {
            color: #6f7c95;
            font-size: 0.72em;
            text-transform: uppercase;
            margin-top: 8px;
            margin-bottom: 4px;
            letter-spacing: 0.03em;
        }
        #walkSearch {
            width: 100%;
            margin-bottom: 10px;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #33435f;
            background: #0f1626;
            color: #d5def0;
            outline: none;
        }
        #walkSearch::placeholder {
            color: #7d8aa4;
        }
        .walk-toggle {
            display: flex;
            align-items: center;
            margin: 4px 0;
            padding: 4px;
            border-radius: 4px;
            cursor: pointer;
        }
        .walk-toggle:hover { background: rgba(255,255,255,0.05); }
        .walk-toggle input[type="checkbox"] { margin-right: 8px; }
        .color-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
            flex-shrink: 0;
        }
        .control-group {
            min-width: 0;
        }
        .view-controls {
            min-width: 0;
        }
        .view-row {
            display: grid;
            grid-template-columns: minmax(72px, 1fr) minmax(82px, 1fr) auto auto auto;
            gap: 4px;
            align-items: center;
        }
        .view-row input,
        .view-row select {
            height: 30px;
            border-radius: 6px;
            border: 1px solid #33435f;
            background: #0f1626;
            color: #d5def0;
            padding: 0 6px;
            font-size: 12px;
        }
        .view-row input {
            flex: 1 1 96px;
            min-width: 72px;
        }
        .view-row select {
            flex: 1 1 110px;
            min-width: 82px;
        }
        .view-row button {
            width: auto;
            min-width: 64px;
            padding: 6px 7px;
            margin: 0;
            white-space: nowrap;
            font-size: 12px;
        }
        .toggle-row {
            display: flex;
            gap: 8px;
            align-items: center;
            height: 28px;
        }
        .toggle-row label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin: 0;
            font-size: 0.92em;
            color: #c4d0ea;
        }
        .toggle-row input[type="checkbox"] {
            margin: 0;
        }
        .spacemouse-row {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: nowrap;
        }
        .sm-speed {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: #9fb0ce;
            white-space: nowrap;
            font-size: 12px;
        }
        #spacemouseSpeed {
            width: 92px;
            margin-top: 0;
        }
        #ctrlSize input[type="range"] {
            width: 82%;
        }
        .spacemouse-row button {
            width: auto;
            min-width: 84px;
            padding: 6px 7px;
            font-size: 12px;
        }
        #spacemouseState {
            font-size: 0.75em;
            color: #8ea2c5;
            min-height: 1.2em;
            margin-top: 4px;
        }
        .sm-debug-toggle {
            margin-top: 4px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: #9fb0ce;
            font-size: 12px;
        }
        #spacemouseDebug {
            margin-top: 4px;
            padding: 6px;
            border: 1px solid #2a3956;
            border-radius: 6px;
            background: rgba(12, 18, 34, 0.85);
            color: #9ec1ff;
            font-size: 11px;
            line-height: 1.25;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 96px;
            overflow: auto;
            font-family: Consolas, 'Courier New', monospace;
        }
        #spacemouseAxisConfig {
            margin-top: 6px;
            padding: 8px;
            border: 1px solid #2a3956;
            border-radius: 6px;
            background: rgba(12, 18, 34, 0.9);
            display: none;
        }
        #spacemouseAxisConfig.visible { display: block; }
        .sm-axis-grid {
            display: grid;
            grid-template-columns: 90px 70px auto 50px;
            gap: 4px 8px;
            align-items: center;
            font-size: 11px;
        }
        .sm-axis-grid .sm-axis-label {
            color: #8ea2c5;
            text-align: right;
        }
        .sm-axis-grid select {
            padding: 3px 4px;
            font-size: 11px;
            background: #1a2540;
            color: #c0d4f0;
            border: 1px solid #3a4a6a;
            border-radius: 4px;
        }
        .sm-axis-grid .sm-axis-value {
            font-family: Consolas, monospace;
            color: #7aff7a;
            min-width: 60px;
            text-align: right;
        }
        .sm-axis-grid label {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            color: #9fb0ce;
            font-size: 11px;
        }
        .sm-axis-header {
            color: #6a8ac0;
            font-weight: bold;
            font-size: 10px;
            text-transform: uppercase;
            padding-bottom: 2px;
            border-bottom: 1px solid #2a3956;
            margin-bottom: 4px;
        }
        label {
            display: block;
            margin-bottom: 2px;
            color: #aaa;
            font-size: 12px;
        }
        input[type="range"] {
            width: 100%;
            margin-top: 0;
        }
        select {
            width: 100%;
            height: 30px;
            border-radius: 6px;
            border: 1px solid #33435f;
            background: #0f1626;
            color: #d5def0;
            padding: 0 8px;
        }
        button {
            width: 118px;
            margin-top: 0;
            padding: 6px 7px;
            background: #335;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover { background: #446; }
        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #333;
            z-index: 100;
            min-width: 180px;
            max-height: calc(100vh - 240px);
            overflow-y: auto;
        }
        #legend h2 {
            font-size: 0.9em;
            color: #7af;
            margin-bottom: 10px;
        }
        #centerBtn {
            width: 100%;
            align-self: end;
        }
        #ctrlSize { grid-column: 1 / span 2; grid-row: 1; }
        #ctrlThick { grid-column: 3 / span 2; grid-row: 1; }
        #ctrlCone { grid-column: 5 / span 2; grid-row: 1; }
        #ctrlGamma { grid-column: 7 / span 2; grid-row: 1; }
        #ctrlDownsample { grid-column: 9 / span 2; grid-row: 1; }
        #ctrlMapping { grid-column: 11 / span 2; grid-row: 1; }
        #ctrlEdgeMode { grid-column: 13 / span 1; grid-row: 1; }
        #centerBtn { grid-column: 14 / span 1; grid-row: 1; }
        #ctrlViews { grid-column: 1 / span 6; grid-row: 2; }
        #ctrlHelpers { grid-column: 7 / span 2; grid-row: 2; }
        #ctrlSpaceMouse { grid-column: 9 / span 4; grid-row: 2; }
        #ctrlMapping select { width: 100%; }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 0.8em;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .legend-stats {
            font-size: 0.7em;
            color: #888;
        }
        @media (max-width: 1200px) {
            #controls {
                width: calc(100vw - 24px);
            }
            #ctrlViews { grid-column: 1 / span 7; }
            #ctrlHelpers { grid-column: 8 / span 2; }
            #ctrlSpaceMouse { grid-column: 10 / span 3; }
        }
        @media (max-width: 900px) {
            #controls {
                width: calc(100vw - 20px);
                grid-template-columns: repeat(12, minmax(58px, 1fr));
            }
            #dataPanel {
                width: 240px;
                max-height: calc(100vh - 220px);
            }
            #statusBanner {
                max-width: calc(100vw - 24px);
            }
            .view-row {
                grid-template-columns: minmax(66px, 1fr) minmax(74px, 1fr) auto auto auto;
            }
        }
        @media (max-width: 720px) {
            .view-row {
                grid-template-columns: minmax(62px, 1fr) minmax(68px, 1fr) auto auto auto;
            }
            .view-row button {
                min-width: 58px;
                width: auto;
            }
            #controls {
                grid-template-columns: repeat(12, minmax(52px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="statusBanner">Loading datasets...</div>

    <div id="dataPanel">
        <h1>Compare Walks</h1>
        <input id="walkSearch" type="text" placeholder="Search datasets...">
        <div id="walkToggles"></div>
    </div>

    <div id="controls">
        <div class="control-group" id="ctrlSize">
            <label>Point Size: <span id="sizeVal">0.4</span></label>
            <input type="range" id="sizeScale" min="0.1" max="10" step="0.05" value="0.4">
        </div>

        <div class="control-group" id="ctrlThick">
            <label>Line Thickness: <span id="thickVal">3</span></label>
            <input type="range" id="thickScale" min="1" max="10" step="0.5" value="3">
        </div>

        <div class="control-group" id="ctrlCone">
            <label>Cone Scale: <span id="coneVal">3</span></label>
            <input type="range" id="coneScale" min="1" max="12" step="0.25" value="3">
        </div>

        <div class="control-group" id="ctrlEdgeMode">
            <label>Edge Mode</label>
            <select id="edgeMode">
                <option value="auto" selected>Auto</option>
                <option value="cones">Cones</option>
                <option value="lines">Lines</option>
            </select>
        </div>

        <div class="control-group" id="ctrlGamma">
            <label>Brightness Gamma: <span id="gammaVal">0.5</span></label>
            <input type="range" id="gamma" min="0.2" max="1.5" step="0.1" value="0.5">
        </div>

        <div class="control-group" id="ctrlDownsample">
            <label>Downsample Limit: <span id="dsVal">30000</span></label>
            <input type="range" id="downsampleLimit" min="2000" max="120000" step="1000" value="30000">
        </div>

        <div class="control-group" id="ctrlMapping">
            <label>Mapping</label>
            <select id="mappingSelect">
                <option value="Original" selected>Original (as generated)</option>
                <option value="Identity">Identity [0,1,...,11]</option>
                <option value="Optimal">Optimal [0,1,2,3,4,5,6,7,10,9,8,11]</option>
                <option value="Spiral">Spiral [0,2,4,6,8,10,1,3,5,7,9,11]</option>
                <option value="LCG">LCG [3,7,11,10,4,0,9,6,5,1,2,8]</option>
                <option value="Stock-opt">Stock-opt [1,0,2,4,10,5,6,9,8,7,3,11]</option>
            </select>
        </div>

        <div class="control-group view-controls" id="ctrlViews">
            <label>Saved Views</label>
            <div class="view-row">
                <input id="viewName" type="text" placeholder="View name">
                <select id="viewList">
                    <option value="">Select view...</option>
                </select>
                <button id="saveViewBtn">Save View</button>
                <button id="loadViewBtn">Load</button>
                <button id="deleteViewBtn">Delete</button>
            </div>
        </div>

        <div class="control-group" id="ctrlHelpers">
            <label>Scene Helpers</label>
            <div class="toggle-row">
                <label><input type="checkbox" id="toggleGrid" checked> Grid</label>
                <label><input type="checkbox" id="toggleAxes" checked> Axes</label>
                <label><input type="checkbox" id="spacemouseDebugToggle"> Debug HID</label>
            </div>
        </div>

        <div class="control-group" id="ctrlSpaceMouse">
            <label>SpaceMouse</label>
            <div class="spacemouse-row">
                <button id="spacemouseConnectBtn">Connect</button>
                <button id="spacemouseDisconnectBtn">Disconnect</button>
                <button id="spacemouseReloadBtn">Reload YAML</button>
                <span class="sm-speed">Speed: <span id="spacemouseSpeedVal">1.0</span></span>
                <input type="range" id="spacemouseSpeed" min="0.2" max="3" step="0.1" value="1.0">
            </div>
            <div id="spacemouseState">Not connected</div>
            <div id="spacemouseDebug" style="display:none">No HID packets yet.</div>
            <div id="spacemouseAxisConfig">
                <div class="sm-axis-grid">
                    <div class="sm-axis-header">Control</div>
                    <div class="sm-axis-header">Source</div>
                    <div class="sm-axis-header">Value</div>
                    <div class="sm-axis-header">Invert</div>

                    <span class="sm-axis-label">Pan X</span>
                    <select id="smAxisSrc_pan_x"><option value="tx">tx</option><option value="ty">ty</option><option value="tz">tz</option><option value="rx">rx</option><option value="ry">ry</option><option value="rz">rz</option></select>
                    <span class="sm-axis-value" id="smVal_pan_x">0</span>
                    <label><input type="checkbox" id="smInv_pan_x"> Inv</label>

                    <span class="sm-axis-label">Pan Y</span>
                    <select id="smAxisSrc_pan_y"><option value="tx">tx</option><option value="ty" selected>ty</option><option value="tz">tz</option><option value="rx">rx</option><option value="ry">ry</option><option value="rz">rz</option></select>
                    <span class="sm-axis-value" id="smVal_pan_y">0</span>
                    <label><input type="checkbox" id="smInv_pan_y"> Inv</label>

                    <span class="sm-axis-label">Dolly (Z)</span>
                    <select id="smAxisSrc_dolly"><option value="tx">tx</option><option value="ty">ty</option><option value="tz" selected>tz</option><option value="rx">rx</option><option value="ry">ry</option><option value="rz">rz</option></select>
                    <span class="sm-axis-value" id="smVal_dolly">0</span>
                    <label><input type="checkbox" id="smInv_dolly"> Inv</label>

                    <span class="sm-axis-label">Orbit Pitch</span>
                    <select id="smAxisSrc_orbit_pitch"><option value="tx">tx</option><option value="ty">ty</option><option value="tz">tz</option><option value="rx" selected>rx</option><option value="ry">ry</option><option value="rz">rz</option></select>
                    <span class="sm-axis-value" id="smVal_orbit_pitch">0</span>
                    <label><input type="checkbox" id="smInv_orbit_pitch" checked> Inv</label>

                    <span class="sm-axis-label">Orbit Yaw</span>
                    <select id="smAxisSrc_orbit_yaw"><option value="tx">tx</option><option value="ty">ty</option><option value="tz">tz</option><option value="rx">rx</option><option value="ry" selected>ry</option><option value="rz">rz</option></select>
                    <span class="sm-axis-value" id="smVal_orbit_yaw">0</span>
                    <label><input type="checkbox" id="smInv_orbit_yaw"> Inv</label>

                    <span class="sm-axis-label">Roll</span>
                    <select id="smAxisSrc_roll"><option value="tx">tx</option><option value="ty">ty</option><option value="tz">tz</option><option value="rx">rx</option><option value="ry">ry</option><option value="rz" selected>rz</option></select>
                    <span class="sm-axis-value" id="smVal_roll">0</span>
                    <label><input type="checkbox" id="smInv_roll" checked> Inv</label>
                </div>
                <div style="margin-top: 8px; display: flex; gap: 8px; align-items: center;">
                    <button id="smSaveYamlBtn" style="font-size: 11px; padding: 4px 10px;">Save to YAML</button>
                    <span id="smSaveStatus" style="font-size: 10px; color: #6a8a6a;"></span>
                </div>
            </div>
        </div>

        <button id="centerBtn">Center View</button>
    </div>

    <div id="legend">
        <h2>Active Walks</h2>
        <div id="legendItems"><span style="color:#666">None selected</span></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "three-fatline": "https://unpkg.com/three-fatline@0.7.1/dist/three-fatline.mjs"
        }
    }
    </script>
    <script src="walk_config.js"></script>
    <script src="https://unpkg.com/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script src="vendor/3dconnexion.min.js"></script>
    <script>
        // 3DconnexionJS defines a global lexical binding in classic script mode.
        // Expose it as a window property so module code can access it reliably.
        try {
            if (!window._3Dconnexion && typeof _3Dconnexion !== 'undefined') {
                window._3Dconnexion = _3Dconnexion;
            }
        } catch (_) {}
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';
        import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';

        // Manifest and file loading info from walk_config.js (SSOT)
        let manifestWalks = []; // loaded from thumbnails/manifest.json
        const FILE_LOADING = window.FILE_LOADING || {};
        const FILE_INFO = window.FILE_INFO || {};

        const WALK_COLORS = {};
        const walkDataById = {};
        const walkDataCache = {};
        const walkInfoById = {};
        const walkOptions = [];
        const walkEntries = [];
        let maxRemappedSteps = 30000;
        let statusEl = null;
        let plottingStatusDepth = 0;
        let plottingStatusShownAt = 0;
        let plottingHideTimer = null;
        const SAVED_VIEWS_KEY = 'neuralWalksSavedViewsV1';
        let savedViews = {};

        // ── Mapping selector state ──
        const NAMED_MAPPINGS = {
            'Identity': [0,1,2,3,4,5,6,7,8,9,10,11],
            'Optimal':  [0,1,2,3,4,5,6,7,10,9,8,11],
            'Spiral':   [0,2,4,6,8,10,1,3,5,7,9,11],
            'LCG':      [3,7,11,10,4,0,9,6,5,1,2,8],
            'Stock-opt':[1,0,2,4,10,5,6,9,8,7,3,11],
        };
        let base12Index = null; // loaded from base12_index.json
        let currentMappingName = 'Original'; // default to original pre-computed data

        async function loadBase12Index() {
            try {
                const resp = await fetch('thumbnails/base12_index.json');
                if (!resp.ok) throw new Error(resp.statusText);
                base12Index = await resp.json();
                console.log(`Base12 index loaded: ${Object.keys(base12Index).length} walks`);
            } catch (e) {
                console.warn('Could not load base12_index.json:', e);
                base12Index = null;
            }
        }

        // Turtle3D walk computation (matches Python scipy Rotation implementation)
        // step: downsample base12 by taking every step'th value (matches Python generator)
        function computeWalkFromBase12(base12, mapping, step) {
            const LOCAL_DIRS = [
                [1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1],
            ];
            const ROT_AXES = [
                [1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1],
            ];
            const angle = 15 * Math.PI / 180;

            function qMul(a, b) {
                return [
                    a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3],
                    a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2],
                    a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1],
                    a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0],
                ];
            }
            function qRotVec(q, v) {
                const qv = [0, v[0], v[1], v[2]];
                const qc = [q[0], -q[1], -q[2], -q[3]];
                const r = qMul(qMul(q, qv), qc);
                return [r[1], r[2], r[3]];
            }
            function qFromAxisAngle(axis, a) {
                const ha = a / 2;
                const s = Math.sin(ha);
                return [Math.cos(ha), axis[0]*s, axis[1]*s, axis[2]*s];
            }

            let pos = [0, 0, 0];
            let rot = [1, 0, 0, 0]; // identity quaternion
            const path = [[0, 0, 0]];
            const s = step || 1;

            for (let i = 0; i < base12.length; i += s) {
                const d = mapping[base12[i] % 12];
                if (d < 6) {
                    const dir = qRotVec(rot, LOCAL_DIRS[d]);
                    pos = [pos[0] + dir[0], pos[1] + dir[1], pos[2] + dir[2]];
                } else {
                    const q = qFromAxisAngle(ROT_AXES[d - 6], angle);
                    rot = qMul(q, rot);
                }
                path.push([pos[0], pos[1], pos[2]]);
            }
            return path;
        }

        function getBase12Key(walkId) {
            // walkId format: "GLOBAL_VAR::walkName"
            // base12_index keys: "filename.js::walkName"
            // Need to map global var → filename
            if (!base12Index) return null;
            const parts = walkId.split('::');
            if (parts.length < 2) return null;
            const globalVar = parts[0];
            const walkName = parts.slice(1).join('::');

            // Find the manifest entry that matches this global var
            const def = SOURCE_DEFS.find(d => d.global === globalVar);
            if (!def) return null;
            // Extract filename from URL
            const url = def.url || '';
            const fname = url.split('/').pop();
            const key = fname + '::' + walkName;
            return base12Index[key] ? key : null;
        }

        function recomputeWalkPoints(walkId, mapping) {
            const b12key = getBase12Key(walkId);
            if (!b12key || !base12Index[b12key]) return null;
            const base12 = base12Index[b12key];
            // Compute the downsampling step that the original generator used.
            // Original: step = max(1, len(b12) // max_points), then walked b12[::step].
            // We recover step from the original point count stored in walkDataById.
            const orig = originalWalkData[walkId];
            let step = 1;
            if (orig && orig.path) {
                const origPts = orig.path.length;
                if (origPts > 1 && base12.length > origPts) {
                    step = Math.round(base12.length / (origPts - 1));
                }
            }
            return computeWalkFromBase12(base12, mapping, step);
        }

        function setStatus(message, done = false) {
            if (!statusEl) statusEl = document.getElementById('statusBanner');
            if (!statusEl) return;
            statusEl.style.display = 'block';
            statusEl.textContent = message;
            if (done) {
                setTimeout(() => {
                    if (statusEl) statusEl.style.display = 'none';
                }, 800);
            }
        }

        function clearStatus() {
            if (!statusEl) statusEl = document.getElementById('statusBanner');
            if (!statusEl) return;
            statusEl.style.display = 'none';
            statusEl.textContent = '';
        }

        function beginPlottingStatus(message = 'Plotting Data...') {
            plottingStatusDepth += 1;
            plottingStatusShownAt = performance.now();
            if (plottingHideTimer) {
                clearTimeout(plottingHideTimer);
                plottingHideTimer = null;
            }
            setStatus(message);
        }

        function endPlottingStatus() {
            plottingStatusDepth = Math.max(0, plottingStatusDepth - 1);
            if (plottingStatusDepth > 0) return;
            const elapsed = performance.now() - plottingStatusShownAt;
            const minVisibleMs = 350;
            const delay = Math.max(0, minVisibleMs - elapsed);
            if (plottingHideTimer) clearTimeout(plottingHideTimer);
            plottingHideTimer = setTimeout(() => {
                clearStatus();
                plottingHideTimer = null;
            }, delay);
        }

        const loadedSourceScripts = new Set();

        function loadScriptByUrl(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.async = true;
                script.onload = resolve;
                script.onerror = () => reject(new Error(`Failed loading script: ${url}`));
                document.head.appendChild(script);
            });
        }

        function resolveGlobalBinding(globalName) {
            if (!globalName) return undefined;
            if (typeof window[globalName] !== 'undefined') return window[globalName];
            try {
                const v = window.eval(globalName);
                if (typeof v !== 'undefined') return v;
            } catch (e) {
                // ignore unresolved global
            }
            return undefined;
        }

        async function loadDatasetsFromManifest() {
            // Load manifest.json (SSOT)
            setStatus('Loading manifest...');
            try {
                const resp = await fetch('thumbnails/manifest.json');
                manifestWalks = await resp.json();
            } catch (err) {
                setStatus('Failed to load manifest.json');
                console.error(err);
                return;
            }

            // Group walks by file to know which data files to load
            const fileSet = new Set(manifestWalks.map(w => w.file));
            const files = Array.from(fileSet).filter(f => FILE_LOADING[f]);

            let i = 0;
            for (const filename of files) {
                i += 1;
                const loadInfo = FILE_LOADING[filename];
                if (!loadInfo) continue;

                const scriptUrl = 'data/' + filename;
                try {
                    if (!loadedSourceScripts.has(scriptUrl)) {
                        setStatus(`Loading data files (${i}/${files.length})...`);
                        await loadScriptByUrl(scriptUrl);
                        loadedSourceScripts.add(scriptUrl);
                    }
                    const resolved = resolveGlobalBinding(loadInfo.global);
                    if (typeof resolved !== 'undefined') {
                        window[loadInfo.global] = resolved;
                    } else {
                        console.warn('Dataset global not found after load:', loadInfo.global, scriptUrl);
                    }
                } catch (err) {
                    console.warn('Dataset source load failed:', scriptUrl, err);
                }
            }
        }

        function hashString(str) {
            let h = 2166136261;
            for (let i = 0; i < str.length; i++) {
                h ^= str.charCodeAt(i);
                h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
            }
            return h >>> 0;
        }

        function colorForId(id) {
            const hue = hashString(id) % 360;
            const c = new THREE.Color();
            c.setHSL(hue / 360, 0.85, 0.55);
            return c.getHex();
        }

        function coordKey(x, y, z) {
            return `${x.toFixed(6)}|${y.toFixed(6)}|${z.toFixed(6)}`;
        }

        function normalizePath(path) {
            if (!Array.isArray(path) || path.length === 0) return null;

            const rawPoints = [];
            for (const node of path) {
                let x, y, z;
                if (Array.isArray(node) && node.length >= 3) {
                    x = Number(node[0]);
                    y = Number(node[1]);
                    z = Number(node[2]);
                } else if (node && typeof node === 'object') {
                    x = Number(node.x);
                    y = Number(node.y);
                    z = Number(node.z);
                } else {
                    continue;
                }
                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) continue;
                rawPoints.push({ x, y, z });
            }
            if (rawPoints.length === 0) return null;

            const stride = Math.max(1, Math.ceil(rawPoints.length / maxRemappedSteps));
            const sampled = [];
            for (let i = 0; i < rawPoints.length; i += stride) sampled.push(rawPoints[i]);
            if (sampled[sampled.length - 1] !== rawPoints[rawPoints.length - 1]) {
                sampled.push(rawPoints[rawPoints.length - 1]);
            }

            const normalized = [];
            const counts = new Map();
            for (const p of sampled) {
                const key = coordKey(p.x, p.y, p.z);
                counts.set(key, (counts.get(key) || 0) + 1);
                normalized.push({ x: p.x, y: p.y, z: p.z, v: 0 });
            }

            let totalStepLen = 0;
            let stepCount = 0;
            for (let i = 0; i < normalized.length - 1; i++) {
                const a = normalized[i];
                const b = normalized[i + 1];
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dz = b.z - a.z;
                totalStepLen += Math.sqrt(dx * dx + dy * dy + dz * dz);
                stepCount += 1;
            }
            const avgStepLen = stepCount > 0 ? totalStepLen / stepCount : 0;

            let maxPointVisits = 0;
            for (const p of normalized) {
                p.v = counts.get(coordKey(p.x, p.y, p.z)) || 1;
                if (p.v > maxPointVisits) maxPointVisits = p.v;
            }
            if (maxPointVisits <= 0) maxPointVisits = 1;

            const uniqueCount = counts.size;
            const revisitRatio = normalized.length > 0
                ? (normalized.length - uniqueCount) / normalized.length
                : 0;

            return {
                points: normalized,
                maxPointVisits,
                revisitRatio,
                avgStepLen,
            };
        }

        function ingestFile(filename) {
            const loadInfo = FILE_LOADING[filename];
            if (!loadInfo) return;

            const root = window[loadInfo.global];
            if (!root || typeof root !== 'object') return;

            let entries = [];
            if (loadInfo.mode === 'walks_path' && root.walks && typeof root.walks === 'object') {
                entries = Object.entries(root.walks);
            } else {
                entries = Object.entries(root);
            }

            for (const [name, raw] of entries) {
                if (!raw || typeof raw !== 'object') continue;
                const path = Array.isArray(raw.path) ? raw.path : raw.points;
                if (!Array.isArray(path) || path.length === 0) continue;

                const id = `${loadInfo.global}::${name}`;
                walkDataById[id] = { path };
                WALK_COLORS[id] = colorForId(id);

                // Use walk_config.js SSOT for per-walk category/subcategory overrides
                const walkCat = window.getWalkCat ? window.getWalkCat(filename, name) : 'other';
                const walkSub = window.getWalkSub ? window.getWalkSub(filename, name) : 'Other';
                const group = window.CAT_NAMES && window.CAT_NAMES[walkCat] || walkCat;

                walkEntries.push({
                    id,
                    name,
                    group: group,
                    subgroup: walkSub,
                    file: filename,
                });
            }
        }

        function buildCatalog() {
            setStatus('Building dataset index...');
            walkOptions.length = 0;
            walkEntries.length = 0;

            // Get unique files from manifest, apply same filters as sources.html
            const BASE4_FILES = window.BASE4_FILES || new Set();
            const HIDDEN_WALKS = window.HIDDEN_WALKS || new Set();
            const isBaseline = window.isBaseline || (() => false);

            const files = [...new Set(manifestWalks.map(w => w.file))]
                .filter(f => FILE_LOADING[f])
                .filter(f => !BASE4_FILES.has(f));
            let i = 0;
            for (const filename of files) {
                ingestFile(filename);
                i += 1;
                setStatus(`Indexing datasets (${i}/${files.length})...`);
            }

            // Build set of walks that exist in manifest (sources.html only shows manifest entries)
            const manifestWalkKeys = new Set(manifestWalks.map(w => `${w.file}::${w.walk}`));

            // Filter to ONLY walks in manifest, then apply same filters as sources.html
            const validEntries = walkEntries.filter(e => {
                const key = `${e.file}::${e.name}`;
                // Must exist in manifest (same as sources.html)
                if (!manifestWalkKeys.has(key)) return false;
                if (HIDDEN_WALKS.has(key)) return false;
                if (isBaseline(e.name)) return false;
                return true;
            });
            walkEntries.length = 0;
            walkEntries.push(...validEntries);

            // Keep labels concise; only disambiguate duplicate dataset names.
            const nameCounts = new Map();
            for (const e of walkEntries) {
                nameCounts.set(e.name, (nameCounts.get(e.name) || 0) + 1);
            }
            for (const e of walkEntries) {
                const duplicate = (nameCounts.get(e.name) || 0) > 1;
                const label = duplicate ? `${e.name} (${e.subgroup})` : e.name;
                walkInfoById[e.id] = { label };
                e.label = label;
            }

            // Build hierarchical group -> subgroup -> items.
            const groupMap = new Map();
            for (const e of walkEntries) {
                if (!groupMap.has(e.group)) groupMap.set(e.group, new Map());
                const subgroupMap = groupMap.get(e.group);
                if (!subgroupMap.has(e.subgroup)) subgroupMap.set(e.subgroup, []);
                subgroupMap.get(e.subgroup).push({ value: e.id, label: e.label });
            }

            for (const [groupName, subgroupMap] of groupMap.entries()) {
                const subgroups = [];
                for (const [subgroupName, items] of subgroupMap.entries()) {
                    items.sort((a, b) => a.label.localeCompare(b.label));
                    subgroups.push({ subgroup: subgroupName, items });
                }
                subgroups.sort((a, b) => a.subgroup.localeCompare(b.subgroup));
                walkOptions.push({ group: groupName, subgroups });
            }
            walkOptions.sort((a, b) => a.group.localeCompare(b.group));
        }

        let scene, camera, renderer, controls;
        let gridHelper = null;
        const axisObjects = [];
        const activeWalks = {}; // walkName -> { points, edges, data }
        const pendingAddTokens = new Map();
        let addTokenCounter = 1;
        const EDGE_LOD_LEVELS = [
            { id: 0, maxDist: 180, stride: 1, radialSegments: 6, pixelCap: 1.5 },
            { id: 1, maxDist: 320, stride: 2, radialSegments: 5, pixelCap: 1.25 },
            { id: 2, maxDist: 600, stride: 4, radialSegments: 4, pixelCap: 1.0 },
            { id: 3, maxDist: Infinity, stride: 8, radialSegments: 3, pixelCap: 0.8 },
        ];
        const MAX_CONE_SEGMENTS = 6000;
        const TARGET_EDGE_PIXEL_STEP = 1.6;
        let currentEdgeLod = EDGE_LOD_LEVELS[0];
        let currentPixelCap = 1.5;
        let edgeRenderMode = 'auto';
        let frameCounter = 0;
        let lastFrameTs = performance.now();
        let spaceMouseDevice = null;
        let spaceMouseDevices = [];
        let spaceMouseConnected = false;
        let spaceMouseAutoConnecting = false;
        let spaceMouseNoPacketTimer = null;
        let spaceMouseProvider = 'none';
        let spaceMouseWs = null;
        let spaceMouseWsUrl = '';
        let spaceMouseNoPacketRecoveryTried = false;
        let spaceMouseSdk = null;
        let spaceMouseSdkClient = null;
        let spaceMouseSdkPollTimer = null;
        let spaceMouseSdkLastAffine = null;
        let spaceMouseSdkPollInFlight = false;
        let spaceMouseAutoRetryTimer = null;
        let spaceMouseAutoConnectInFlight = false;
        const SPACEMOUSE_LOG_ENDPOINT = '/_logs/spacemouse';
        const SPACEMOUSE_LOG_FLUSH_MS = 900;
        const SPACEMOUSE_LOG_MAX_QUEUE = 300;
        const SPACEMOUSE_LOG_SAMPLE_EVERY = 50;
        const spaceMouseSessionId = `sm-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
        const SPACEMOUSE_OWNER_KEY = 'pcpri_spacemouse_owner_v1';
        const SPACEMOUSE_OWNER_STALE_MS = 4500;
        const SPACEMOUSE_OWNER_HEARTBEAT_MS = 1200;
        const spaceMouseTabId = `smtab-${Math.random().toString(36).slice(2, 10)}`;
        let spaceMouseIsOwner = false;
        let spaceMouseOwnerBeatTimer = null;
        let spaceMouseLogQueue = [];
        let spaceMouseLogTimer = null;
        const SPACEMOUSE_CONFIG_PATH = './spacemouse_config.yaml';
        const DEFAULT_SPACEMOUSE_MAPPING = {
            axes: {
                pan_x: { source: 'tx', scale: 1.0, invert: false, deadzone: 20, max_abs: 350 },
                pan_y: { source: 'ty', scale: 1.0, invert: false, deadzone: 20, max_abs: 350 },
                dolly: { source: 'tz', scale: 1.0, invert: false, deadzone: 20, max_abs: 350 },
                orbit_pitch: { source: 'rx', scale: 1.0, invert: true, deadzone: 20, max_abs: 350 },
                orbit_yaw: { source: 'ry', scale: 1.0, invert: false, deadzone: 20, max_abs: 350 },
                roll: { source: 'rz', scale: 1.0, invert: true, deadzone: 20, max_abs: 350 },
            },
            motion: {
                pan_gain: 0.25,
                dolly_gain: 0.6,
                rotate_gain: 1.8,
                roll_gain: 0.8,
                input_smoothing_hz: 18.0,
                max_delta_sec: 0.05,
                max_yaw_pitch_rad_per_frame: 0.09,
                max_roll_rad_per_frame: 0.08,
            },
            buttons: {
                0: 'center_view',
                1: 'toggle_grid',
            },
        };
        function cloneSpaceMouseMapping(mapping) {
            return JSON.parse(JSON.stringify(mapping));
        }
        let spaceMouseMapping = cloneSpaceMouseMapping(DEFAULT_SPACEMOUSE_MAPPING);
        const spaceMouseInput = {
            tx: 0, ty: 0, tz: 0,
            rx: 0, ry: 0, rz: 0,
            buttons: 0,
            prevButtons: 0,
            lastReportAt: 0,
        };
        const spaceMouseFiltered = {
            pan_x: 0, pan_y: 0, dolly: 0,
            orbit_pitch: 0, orbit_yaw: 0, roll: 0,
        };
        const WORLD_UP = new THREE.Vector3(0, 1, 0);
        const spaceMouseDebugState = {
            enabled: false,
            lastRenderAt: 0,
            reportId: '-',
            parseRoute: '-',
            kind: '-',
            bytes: 0,
            hex: '',
            packetCount: 0,
            parseErrorCount: 0,
            routeCounts: {},
            lastPacketAt: 0,
            lastError: '',
            deviceSummary: '',
            wsConnected: false,
            wsMessages: 0,
            sdkMessages: 0,
        };

        function updateSpaceMouseUi(message, connected = false) {
            const stateEl = document.getElementById('spacemouseState');
            const connectBtn = document.getElementById('spacemouseConnectBtn');
            const disconnectBtn = document.getElementById('spacemouseDisconnectBtn');
            if (stateEl) stateEl.textContent = message;
            if (connectBtn) connectBtn.disabled = connected;
            if (disconnectBtn) disconnectBtn.disabled = !connected;
            enqueueSpaceMouseLog('ui', { message, connected });
        }

        function readSpaceMouseOwner() {
            try {
                const raw = localStorage.getItem(SPACEMOUSE_OWNER_KEY);
                if (!raw) return null;
                const obj = JSON.parse(raw);
                if (!obj || typeof obj !== 'object') return null;
                const ts = Number(obj.ts);
                const id = `${obj.id || ''}`;
                if (!id || !Number.isFinite(ts)) return null;
                return { id, ts, href: `${obj.href || ''}` };
            } catch (_) {
                return null;
            }
        }

        function writeSpaceMouseOwner() {
            const rec = { id: spaceMouseTabId, ts: Date.now(), href: window.location.href };
            try {
                localStorage.setItem(SPACEMOUSE_OWNER_KEY, JSON.stringify(rec));
                return true;
            } catch (_) {
                return false;
            }
        }

        function startSpaceMouseOwnerHeartbeat() {
            if (!spaceMouseIsOwner) return;
            if (spaceMouseOwnerBeatTimer) return;
            spaceMouseOwnerBeatTimer = setInterval(() => {
                if (!spaceMouseIsOwner) return;
                writeSpaceMouseOwner();
            }, SPACEMOUSE_OWNER_HEARTBEAT_MS);
        }

        function stopSpaceMouseOwnerHeartbeat() {
            if (spaceMouseOwnerBeatTimer) {
                clearInterval(spaceMouseOwnerBeatTimer);
                spaceMouseOwnerBeatTimer = null;
            }
        }

        function releaseSpaceMouseOwnership(reason = 'release') {
            const owner = readSpaceMouseOwner();
            if (owner && owner.id === spaceMouseTabId) {
                try { localStorage.removeItem(SPACEMOUSE_OWNER_KEY); } catch (_) {}
            }
            if (spaceMouseIsOwner) {
                enqueueSpaceMouseLog('owner_release', { reason });
            }
            spaceMouseIsOwner = false;
            stopSpaceMouseOwnerHeartbeat();
        }

        function ensureSpaceMouseOwnership(reason = 'owner_check') {
            const now = Date.now();
            const owner = readSpaceMouseOwner();
            const stale = !owner || (now - owner.ts) > SPACEMOUSE_OWNER_STALE_MS;
            if (!owner || owner.id === spaceMouseTabId || stale) {
                writeSpaceMouseOwner();
                const verify = readSpaceMouseOwner();
                spaceMouseIsOwner = !!verify && verify.id === spaceMouseTabId;
                if (spaceMouseIsOwner) {
                    enqueueSpaceMouseLog('owner_acquire', { reason, stale: !!stale });
                    startSpaceMouseOwnerHeartbeat();
                    return true;
                }
            }
            spaceMouseIsOwner = false;
            stopSpaceMouseOwnerHeartbeat();
            enqueueSpaceMouseLog('owner_busy', { reason, ownerId: owner?.id || '', ownerHref: owner?.href || '' });
            return false;
        }

        function clearSpaceMouseNoPacketWatchdog() {
            if (spaceMouseNoPacketTimer) {
                clearTimeout(spaceMouseNoPacketTimer);
                spaceMouseNoPacketTimer = null;
            }
        }

        function clearSpaceMouseAutoRetryTimer() {
            if (spaceMouseAutoRetryTimer) {
                clearTimeout(spaceMouseAutoRetryTimer);
                spaceMouseAutoRetryTimer = null;
            }
        }

        function scheduleSpaceMouseAutoRetry(reason = 'retry') {
            if (spaceMouseConnected) return;
            if (spaceMouseAutoRetryTimer) return;
            spaceMouseAutoRetryTimer = setTimeout(() => {
                spaceMouseAutoRetryTimer = null;
                autoConnectSpaceMouseAll(reason);
            }, 8000);
        }

        function scheduleSpaceMouseLogFlush() {
            if (spaceMouseLogTimer) return;
            spaceMouseLogTimer = setTimeout(() => {
                spaceMouseLogTimer = null;
                flushSpaceMouseLogs(false);
            }, SPACEMOUSE_LOG_FLUSH_MS);
        }

        function enqueueSpaceMouseLog(type, payload = {}) {
            const evt = {
                ts: new Date().toISOString(),
                perf_ms: Math.round(performance.now()),
                session: spaceMouseSessionId,
                type,
                provider: spaceMouseProvider,
                connected: !!spaceMouseConnected,
                payload,
            };
            spaceMouseLogQueue.push(evt);
            if (spaceMouseLogQueue.length > SPACEMOUSE_LOG_MAX_QUEUE) {
                spaceMouseLogQueue = spaceMouseLogQueue.slice(spaceMouseLogQueue.length - SPACEMOUSE_LOG_MAX_QUEUE);
            }
            scheduleSpaceMouseLogFlush();
        }

        async function flushSpaceMouseLogs(forceBeacon = false) {
            if (!spaceMouseLogQueue.length) return;
            const batch = spaceMouseLogQueue.slice(0, 80);
            const body = JSON.stringify(batch);
            if (forceBeacon && navigator.sendBeacon) {
                const ok = navigator.sendBeacon(SPACEMOUSE_LOG_ENDPOINT, new Blob([body], { type: 'application/json' }));
                if (ok) {
                    spaceMouseLogQueue = spaceMouseLogQueue.slice(batch.length);
                }
                return;
            }
            try {
                const res = await fetch(SPACEMOUSE_LOG_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body,
                    keepalive: true,
                });
                if (res.ok) {
                    spaceMouseLogQueue = spaceMouseLogQueue.slice(batch.length);
                }
            } catch (_) {
                // Keep queue for retry.
            }
        }

        function renderSpaceMouseDebug(force = false) {
            const panel = document.getElementById('spacemouseDebug');
            if (!panel || !spaceMouseDebugState.enabled) return;
            const now = performance.now();
            if (!force && (now - spaceMouseDebugState.lastRenderAt) < 40) return;
            spaceMouseDebugState.lastRenderAt = now;
            const routeSummary = Object.entries(spaceMouseDebugState.routeCounts || {})
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8)
                .map(([k, v]) => `${k}:${v}`)
                .join(' ');
            const msSincePacket = spaceMouseDebugState.lastPacketAt > 0
                ? Math.max(0, Math.round(now - spaceMouseDebugState.lastPacketAt))
                : -1;
            panel.textContent =
                `rid=${spaceMouseDebugState.reportId} route=${spaceMouseDebugState.parseRoute} kind=${spaceMouseDebugState.kind} bytes=${spaceMouseDebugState.bytes}\n` +
                `packets=${spaceMouseDebugState.packetCount} parseErrors=${spaceMouseDebugState.parseErrorCount} lastPacketMs=${msSincePacket}\n` +
                `provider=${spaceMouseProvider} wsConnected=${spaceMouseDebugState.wsConnected} wsMessages=${spaceMouseDebugState.wsMessages}\n` +
                `sdkMessages=${spaceMouseDebugState.sdkMessages}\n` +
                `tx=${spaceMouseInput.tx} ty=${spaceMouseInput.ty} tz=${spaceMouseInput.tz}\n` +
                `rx=${spaceMouseInput.rx} ry=${spaceMouseInput.ry} rz=${spaceMouseInput.rz} btn=0x${(spaceMouseInput.buttons || 0).toString(16)}\n` +
                `cfg invert: rx=${!!spaceMouseMapping?.axes?.orbit_pitch?.invert} rz=${!!spaceMouseMapping?.axes?.roll?.invert}\n` +
                `routes=${routeSummary || '-'}\n` +
                `device=${spaceMouseDebugState.deviceSummary || '-'}\n` +
                `lastError=${spaceMouseDebugState.lastError || '-'}\n` +
                `hex=${spaceMouseDebugState.hex || '-'}`;
        }

        function closeSpaceMouseWebSocket() {
            if (!spaceMouseWs) return;
            try {
                spaceMouseWs.onopen = null;
                spaceMouseWs.onclose = null;
                spaceMouseWs.onerror = null;
                spaceMouseWs.onmessage = null;
                if (spaceMouseWs.readyState === WebSocket.OPEN || spaceMouseWs.readyState === WebSocket.CONNECTING) {
                    spaceMouseWs.close();
                }
            } catch (err) {
                console.warn('SpaceMouse websocket close error:', err);
            }
            spaceMouseWs = null;
            spaceMouseWsUrl = '';
            spaceMouseDebugState.wsConnected = false;
            enqueueSpaceMouseLog('ws_close', {});
        }

        function focusSpaceMouseSdk(reason = 'focus') {
            if (!spaceMouseSdk || typeof spaceMouseSdk.focus !== 'function') return false;
            try {
                spaceMouseSdk.focus();
                enqueueSpaceMouseLog('sdk_focus', { reason });
                return true;
            } catch (err) {
                enqueueSpaceMouseLog('sdk_focus_error', { reason, detail: err?.message || String(err) });
                return false;
            }
        }

        function blurSpaceMouseSdk(reason = 'blur') {
            if (!spaceMouseSdk || typeof spaceMouseSdk.blur !== 'function') return false;
            try {
                spaceMouseSdk.blur();
                enqueueSpaceMouseLog('sdk_blur', { reason });
                return true;
            } catch (err) {
                enqueueSpaceMouseLog('sdk_blur_error', { reason, detail: err?.message || String(err) });
                return false;
            }
        }

        function stopSpaceMouseSdkPoll() {
            if (spaceMouseSdkPollTimer) {
                clearInterval(spaceMouseSdkPollTimer);
                spaceMouseSdkPollTimer = null;
            }
            spaceMouseSdkPollInFlight = false;
            spaceMouseSdkLastAffine = null;
        }

        function describeError(err) {
            if (!err) return 'unknown';
            const out = {
                type: Object.prototype.toString.call(err),
                message: err?.message || '',
                error: err?.error || '',
                desc: err?.desc || err?.description || '',
                uri: err?.uri || '',
                code: Number.isFinite(Number(err?.code)) ? Number(err.code) : null,
            };
            try {
                const keys = Object.keys(err || {});
                if (keys.length > 0) out.keys = keys.slice(0, 12);
            } catch (_) {}
            try { return JSON.stringify(out); } catch (_) { return `${err}`; }
        }

        function startSpaceMouseSdkPoll() {
            // Polling caused frequent SDK RPC errors in this environment.
            // Keep disabled by default and rely on SDK push updates.
            enqueueSpaceMouseLog('sdk_poll_disabled', {});
            return;
            stopSpaceMouseSdkPoll();
            if (!spaceMouseSdk || typeof spaceMouseSdk.read3dcontroller !== 'function') return;
            let tick = 0;
            spaceMouseSdkPollTimer = setInterval(async () => {
                if (!spaceMouseSdk || spaceMouseProvider !== '3dx-sdk') return;
                if (spaceMouseSdkPollInFlight) return;
                spaceMouseSdkPollInFlight = true;
                try {
                    const affine = await spaceMouseSdk.read3dcontroller('view.affine');
                    const arr = toNumArray(affine);
                    if (arr && arr.length >= 16) {
                        const prev = spaceMouseSdkLastAffine;
                        let changed = !Array.isArray(prev) || prev.length < 16;
                        if (!changed) {
                            for (let i = 0; i < 16; i += 1) {
                                if (Math.abs(arr[i] - prev[i]) > 1e-7) {
                                    changed = true;
                                    break;
                                }
                            }
                        }
                        if (changed) {
                            spaceMouseSdkLastAffine = arr.slice(0, 16);
                            if (spaceMouseSdkClient?.setViewMatrix) {
                                spaceMouseSdkClient.setViewMatrix(arr);
                            }
                            if (tick <= 3 || (tick % SPACEMOUSE_LOG_SAMPLE_EVERY) === 0) {
                                enqueueSpaceMouseLog('sdk_poll_affine', { changed: true });
                            }
                        } else if (tick <= 2) {
                            enqueueSpaceMouseLog('sdk_poll_affine', { changed: false });
                        }
                    } else if (tick <= 3) {
                        enqueueSpaceMouseLog('sdk_poll_affine_invalid', {
                            hasValue: !!affine,
                            type: affine ? Object.prototype.toString.call(affine) : 'null',
                        });
                    }
                    if ((tick % 20) === 0) {
                        try {
                            const moving = await spaceMouseSdk.read3dcontroller('motion');
                            enqueueSpaceMouseLog('sdk_poll_motion', { moving: !!moving });
                        } catch (_) {}
                    }
                } catch (err) {
                    if (tick <= 4 || (tick % SPACEMOUSE_LOG_SAMPLE_EVERY) === 0) {
                        enqueueSpaceMouseLog('sdk_poll_error', { detail: describeError(err) });
                    }
                } finally {
                    tick += 1;
                    spaceMouseSdkPollInFlight = false;
                }
            }, 90);
            enqueueSpaceMouseLog('sdk_poll_start', {});
        }

        function pushSpaceMouseSdkFocusState(reason = 'sdk_focus_state') {
            if (!spaceMouseSdk || typeof spaceMouseSdk.update3dcontroller !== 'function') return;
            try {
                spaceMouseSdk.update3dcontroller({ focus: true, motion: true });
                enqueueSpaceMouseLog('sdk_update3dcontroller', { reason, focus: true, motion: true });
            } catch (err) {
                enqueueSpaceMouseLog('sdk_update3dcontroller_error', { reason, detail: describeError(err) });
            }
        }

        function onSpaceMouseDebugToggle() {
            const enabled = !!document.getElementById('spacemouseDebugToggle')?.checked;
            const panel = document.getElementById('spacemouseDebug');
            const axisPanel = document.getElementById('spacemouseAxisConfig');
            spaceMouseDebugState.enabled = enabled;
            if (panel) panel.style.display = enabled ? 'block' : 'none';
            if (axisPanel) axisPanel.classList.toggle('visible', enabled);
            enqueueSpaceMouseLog('debug_toggle', { enabled });
            if (enabled) {
                renderSpaceMouseDebug(true);
                syncAxisConfigUI();
            }
        }

        // Axis configuration panel functions
        const SM_AXIS_NAMES = ['pan_x', 'pan_y', 'dolly', 'orbit_pitch', 'orbit_yaw', 'roll'];
        const SM_SOURCES = ['tx', 'ty', 'tz', 'rx', 'ry', 'rz'];

        function syncAxisConfigUI() {
            for (const axis of SM_AXIS_NAMES) {
                const srcEl = document.getElementById(`smAxisSrc_${axis}`);
                const invEl = document.getElementById(`smInv_${axis}`);
                const cfg = spaceMouseMapping?.axes?.[axis];
                if (srcEl && cfg?.source) srcEl.value = cfg.source;
                if (invEl && typeof cfg?.invert === 'boolean') invEl.checked = cfg.invert;
            }
        }

        function onAxisSourceChange(axis, newSource) {
            if (!spaceMouseMapping?.axes?.[axis]) return;
            spaceMouseMapping.axes[axis].source = newSource;
            enqueueSpaceMouseLog('axis_config_change', { axis, source: newSource });
        }

        function onAxisInvertChange(axis, invert) {
            if (!spaceMouseMapping?.axes?.[axis]) return;
            spaceMouseMapping.axes[axis].invert = invert;
            enqueueSpaceMouseLog('axis_config_change', { axis, invert });
        }

        function updateAxisValueDisplays() {
            if (!spaceMouseDebugState.enabled) return;
            for (const axis of SM_AXIS_NAMES) {
                const valEl = document.getElementById(`smVal_${axis}`);
                if (!valEl) continue;
                const cfg = spaceMouseMapping?.axes?.[axis];
                const src = cfg?.source || axis;
                const raw = spaceMouseInput[src] || 0;
                const inv = cfg?.invert ? -1 : 1;
                const val = raw * inv;
                valEl.textContent = val.toFixed(0);
                valEl.style.color = Math.abs(val) > 20 ? '#7aff7a' : '#5a7a5a';
            }
        }

        function setupAxisConfigListeners() {
            for (const axis of SM_AXIS_NAMES) {
                const srcEl = document.getElementById(`smAxisSrc_${axis}`);
                const invEl = document.getElementById(`smInv_${axis}`);
                if (srcEl) {
                    srcEl.addEventListener('change', () => onAxisSourceChange(axis, srcEl.value));
                }
                if (invEl) {
                    invEl.addEventListener('change', () => onAxisInvertChange(axis, invEl.checked));
                }
            }
            const saveBtn = document.getElementById('smSaveYamlBtn');
            if (saveBtn) {
                saveBtn.addEventListener('click', saveSpaceMouseConfigToYaml);
            }
        }

        function generateSpaceMouseYaml() {
            const lines = ['version: 1', '', 'axes:'];
            const axisLabels = {
                pan_x: 'pan_x', pan_y: 'pan_y', dolly: 'dolly',
                orbit_pitch: 'orbit_pitch', orbit_yaw: 'orbit_yaw', roll: 'roll'
            };
            for (const axis of SM_AXIS_NAMES) {
                const cfg = spaceMouseMapping?.axes?.[axis] || {};
                lines.push(`  ${axisLabels[axis]}:`);
                lines.push(`    source: ${cfg.source || axis}`);
                lines.push(`    scale: ${cfg.scale ?? 1.0}`);
                lines.push(`    invert: ${cfg.invert ? 'true' : 'false'}`);
                lines.push(`    deadzone: ${cfg.deadzone ?? 20}`);
                lines.push(`    max_abs: ${cfg.max_abs ?? 350}`);
            }
            lines.push('');
            lines.push('motion:');
            const motion = spaceMouseMapping?.motion || {};
            lines.push(`  pan_gain: ${motion.pan_gain ?? 0.25}`);
            lines.push(`  dolly_gain: ${motion.dolly_gain ?? 0.6}`);
            lines.push(`  rotate_gain: ${motion.rotate_gain ?? 1.8}`);
            lines.push(`  roll_gain: ${motion.roll_gain ?? 0.8}`);
            lines.push(`  input_smoothing_hz: ${motion.input_smoothing_hz ?? 18.0}`);
            lines.push(`  max_delta_sec: ${motion.max_delta_sec ?? 0.05}`);
            lines.push(`  max_yaw_pitch_rad_per_frame: ${motion.max_yaw_pitch_rad_per_frame ?? 0.09}`);
            lines.push(`  max_roll_rad_per_frame: ${motion.max_roll_rad_per_frame ?? 0.08}`);
            lines.push('');
            lines.push('buttons:');
            const buttons = spaceMouseMapping?.buttons || {};
            for (const [key, action] of Object.entries(buttons)) {
                lines.push(`  ${key}: ${action}`);
            }
            lines.push('  # Available actions:');
            lines.push('  # - center_view');
            lines.push('  # - toggle_grid');
            lines.push('  # - toggle_axes');
            lines.push('  # - load_selected_view');
            lines.push('  # - save_quick_view');
            lines.push('  # - cycle_saved_view');
            lines.push('');
            return lines.join('\n');
        }

        async function saveSpaceMouseConfigToYaml() {
            const statusEl = document.getElementById('smSaveStatus');
            const btn = document.getElementById('smSaveYamlBtn');
            if (btn) btn.disabled = true;
            if (statusEl) statusEl.textContent = 'Saving...';
            try {
                const yaml = generateSpaceMouseYaml();
                const response = await fetch('/_config/spacemouse', {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: yaml,
                });
                if (response.ok) {
                    if (statusEl) {
                        statusEl.textContent = 'Saved!';
                        statusEl.style.color = '#7aff7a';
                    }
                    enqueueSpaceMouseLog('config_saved', { ok: true });
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (err) {
                if (statusEl) {
                    statusEl.textContent = `Error: ${err.message}`;
                    statusEl.style.color = '#ff7a7a';
                }
                enqueueSpaceMouseLog('config_save_error', { detail: err.message });
            } finally {
                if (btn) btn.disabled = false;
                setTimeout(() => {
                    if (statusEl) statusEl.textContent = '';
                }, 3000);
            }
        }

        function updateSpaceMouseDebugFromReport(reportId, data, parseRoute, kind = '-') {
            spaceMouseDebugState.reportId = Number.isFinite(reportId) ? String(reportId) : `${reportId}`;
            spaceMouseDebugState.parseRoute = parseRoute || '-';
            spaceMouseDebugState.kind = Number.isFinite(kind) ? String(kind) : `${kind}`;
            spaceMouseDebugState.packetCount += 1;
            spaceMouseDebugState.lastPacketAt = performance.now();
            if (parseRoute) {
                const curr = Number(spaceMouseDebugState.routeCounts[parseRoute] || 0);
                spaceMouseDebugState.routeCounts[parseRoute] = curr + 1;
            }
            if (
                parseRoute === 'parse-error' ||
                parseRoute === 'unparsed' ||
                spaceMouseDebugState.packetCount <= 3 ||
                (spaceMouseDebugState.packetCount % SPACEMOUSE_LOG_SAMPLE_EVERY) === 0
            ) {
                enqueueSpaceMouseLog('packet', {
                    reportId: spaceMouseDebugState.reportId,
                    parseRoute: spaceMouseDebugState.parseRoute,
                    kind: spaceMouseDebugState.kind,
                    bytes: spaceMouseDebugState.bytes,
                    packetCount: spaceMouseDebugState.packetCount,
                    tx: spaceMouseInput.tx,
                    ty: spaceMouseInput.ty,
                    tz: spaceMouseInput.tz,
                    rx: spaceMouseInput.rx,
                    ry: spaceMouseInput.ry,
                    rz: spaceMouseInput.rz,
                    buttons: spaceMouseInput.buttons,
                });
            }
            const bytes = getByteLength(data);
            spaceMouseDebugState.bytes = bytes;
            if (bytes > 0) {
                const u8All = toU8View(data);
                const n = Math.min(bytes, 20);
                const u8 = u8All ? u8All.subarray(0, n) : null;
                if (!u8) {
                    spaceMouseDebugState.hex = '';
                    renderSpaceMouseDebug(false);
                    return;
                }
                spaceMouseDebugState.hex = Array.from(u8).map(v => v.toString(16).padStart(2, '0')).join(' ');
            } else {
                spaceMouseDebugState.hex = '';
            }
            renderSpaceMouseDebug(false);
        }

        function toU8View(data) {
            if (!data) return null;
            if (data instanceof Uint8Array) return data;
            if (ArrayBuffer.isView(data) && data.buffer) {
                return new Uint8Array(data.buffer, data.byteOffset || 0, data.byteLength || 0);
            }
            if (data instanceof ArrayBuffer) {
                return new Uint8Array(data);
            }
            return null;
        }

        function getByteLength(data) {
            if (!data) return 0;
            if (typeof data.byteLength === 'number') return data.byteLength;
            const u8 = toU8View(data);
            return u8 ? u8.byteLength : 0;
        }

        function readU8(data, offset) {
            if (!Number.isInteger(offset) || offset < 0) return 0;
            if (data && typeof data.getUint8 === 'function' && offset < getByteLength(data)) {
                return data.getUint8(offset);
            }
            const u8 = toU8View(data);
            if (!u8 || offset >= u8.length) return 0;
            return u8[offset];
        }

        function readU16LE(data, offset) {
            const lo = readU8(data, offset);
            const hi = readU8(data, offset + 1);
            return (hi << 8) | lo;
        }

        function readI16LE(data, offset) {
            const val = readU16LE(data, offset);
            return (val & 0x8000) ? (val - 0x10000) : val;
        }

        function decodeInt16(data, offset) {
            if (!data || (offset + 1) >= getByteLength(data)) return 0;
            return readI16LE(data, offset);
        }

        function readAxisTriplet(data, offset = 0) {
            return [
                decodeInt16(data, offset),
                decodeInt16(data, offset + 2),
                decodeInt16(data, offset + 4),
            ];
        }

        function collectReportIds(collection, acc) {
            if (!collection || typeof collection !== 'object') return;
            const reports = Array.isArray(collection.inputReports) ? collection.inputReports : [];
            for (const r of reports) {
                const rid = Number(r?.reportId);
                if (Number.isFinite(rid)) acc.add(rid);
            }
            const children = Array.isArray(collection.children) ? collection.children : [];
            for (const child of children) {
                collectReportIds(child, acc);
            }
        }

        function describeHidDevice(device) {
            if (!device) return '';
            const reportIds = new Set();
            const cols = Array.isArray(device.collections) ? device.collections : [];
            for (const c of cols) collectReportIds(c, reportIds);
            const sortedIds = Array.from(reportIds).sort((a, b) => a - b);
            const idPart = sortedIds.length > 0 ? sortedIds.join(',') : '-';
            const product = `${device.productName || 'unknown'}`.trim();
            return `${product} vid=0x${(device.vendorId || 0).toString(16)} pid=0x${(device.productId || 0).toString(16)} opened=${!!device.opened} reports=[${idPart}]`;
        }

        function refreshSpaceMouseDeviceDebugSummary() {
            const list = Array.isArray(spaceMouseDevices) ? spaceMouseDevices.filter(Boolean) : [];
            if (list.length === 0 && spaceMouseDevice) {
                spaceMouseDebugState.deviceSummary = describeHidDevice(spaceMouseDevice);
                return;
            }
            if (list.length === 0) {
                spaceMouseDebugState.deviceSummary = '';
                return;
            }
            spaceMouseDebugState.deviceSummary = list.map(describeHidDevice).join(' | ');
        }

        function mapSpaceMouseControl(name) {
            const cfg = spaceMouseMapping?.axes?.[name] || {};
            const source = cfg.source || 'tx';
            const raw = Number(spaceMouseInput[source] || 0);
            const deadzone = Number(cfg.deadzone ?? 20);
            const maxAbs = Number(cfg.max_abs ?? 350);
            const scale = Number(cfg.scale ?? 1);
            const invert = !!cfg.invert;
            if (!Number.isFinite(raw)) return 0;
            if (Math.abs(raw) <= deadzone) return 0;
            if (!Number.isFinite(maxAbs) || maxAbs <= 0) return 0;
            let normalized = raw / maxAbs;
            if (invert) normalized *= -1;
            normalized *= scale;
            return THREE.MathUtils.clamp(normalized, -2, 2);
        }

        function getMotionGain(name, fallback) {
            const val = Number(spaceMouseMapping?.motion?.[name]);
            if (Number.isFinite(val) && val > 0) return val;
            return fallback;
        }

        function triggerSpaceMouseAction(action) {
            if (!action) return;
            if (action === 'center_view') {
                centerCamera();
                return;
            }
            if (action === 'toggle_grid') {
                const cb = document.getElementById('toggleGrid');
                if (!cb) return;
                cb.checked = !cb.checked;
                onToggleHelpers();
                return;
            }
            if (action === 'toggle_axes') {
                const cb = document.getElementById('toggleAxes');
                if (!cb) return;
                cb.checked = !cb.checked;
                onToggleHelpers();
                return;
            }
            if (action === 'load_selected_view') {
                loadSelectedView();
                return;
            }
            if (action === 'save_quick_view') {
                const input = document.getElementById('viewName');
                if (input && !input.value.trim()) input.value = 'quick-view';
                saveCurrentView();
                return;
            }
            if (action === 'cycle_saved_view') {
                const select = document.getElementById('viewList');
                if (!select || select.options.length <= 1) return;
                const idx = Math.max(0, select.selectedIndex);
                const next = (idx + 1) % select.options.length;
                select.selectedIndex = next === 0 ? 1 : next;
                loadSelectedView();
                return;
            }
            console.warn('Unknown SpaceMouse action:', action);
        }

        function handleSpaceMouseButtons(nextMask) {
            const prevMask = spaceMouseInput.prevButtons || 0;
            const bindings = spaceMouseMapping?.buttons || {};
            for (const [btnKey, action] of Object.entries(bindings)) {
                const idx = Number.parseInt(btnKey, 10);
                if (!Number.isInteger(idx) || idx < 0 || idx > 30) continue;
                const bit = (1 << idx);
                const wasDown = (prevMask & bit) !== 0;
                const nowDown = (nextMask & bit) !== 0;
                if (!wasDown && nowDown) {
                    triggerSpaceMouseAction(action);
                }
            }
            spaceMouseInput.prevButtons = nextMask;
        }

        function validateSpaceMouseMapping(candidate) {
            if (!candidate || typeof candidate !== 'object') {
                throw new Error('Config root must be a YAML object.');
            }
            if (candidate.axes && typeof candidate.axes !== 'object') {
                throw new Error('axes must be an object.');
            }
            if (candidate.motion && typeof candidate.motion !== 'object') {
                throw new Error('motion must be an object.');
            }
            if (candidate.buttons && typeof candidate.buttons !== 'object') {
                throw new Error('buttons must be an object.');
            }
        }

        async function reloadSpaceMouseMappingFromYaml() {
            if (!window.jsyaml || typeof window.jsyaml.load !== 'function') {
                updateSpaceMouseUi('YAML parser not available.', spaceMouseConnected);
                return false;
            }
            try {
                const response = await fetch(SPACEMOUSE_CONFIG_PATH, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`YAML file missing at ${SPACEMOUSE_CONFIG_PATH}`);
                }
                const yamlText = await response.text();
                const parsed = window.jsyaml.load(yamlText) || {};
                validateSpaceMouseMapping(parsed);
                spaceMouseMapping = {
                    axes: { ...DEFAULT_SPACEMOUSE_MAPPING.axes, ...(parsed.axes || {}) },
                    motion: { ...DEFAULT_SPACEMOUSE_MAPPING.motion, ...(parsed.motion || {}) },
                    buttons: { ...DEFAULT_SPACEMOUSE_MAPPING.buttons, ...(parsed.buttons || {}) },
                };
                const statePrefix = spaceMouseConnected ? 'Connected' : 'Not connected';
                updateSpaceMouseUi(`${statePrefix} | YAML loaded`, spaceMouseConnected);
                syncAxisConfigUI();
                return true;
            } catch (err) {
                spaceMouseMapping = cloneSpaceMouseMapping(DEFAULT_SPACEMOUSE_MAPPING);
                const detail = err?.message || String(err);
                const fileHint = (window.location.protocol === 'file:') ? ' (file:// mode may block YAML fetch; use local server)' : '';
                updateSpaceMouseUi(`YAML load failed, using defaults: ${detail}${fileHint}`, spaceMouseConnected);
                return false;
            }
        }

        function resetSpaceMouseInput() {
            spaceMouseInput.tx = 0;
            spaceMouseInput.ty = 0;
            spaceMouseInput.tz = 0;
            spaceMouseInput.rx = 0;
            spaceMouseInput.ry = 0;
            spaceMouseInput.rz = 0;
            spaceMouseInput.buttons = 0;
            spaceMouseInput.prevButtons = 0;
            spaceMouseInput.lastReportAt = 0;
            spaceMouseFiltered.pan_x = 0;
            spaceMouseFiltered.pan_y = 0;
            spaceMouseFiltered.dolly = 0;
            spaceMouseFiltered.orbit_pitch = 0;
            spaceMouseFiltered.orbit_yaw = 0;
            spaceMouseFiltered.roll = 0;
            spaceMouseDebugState.lastError = '';
            spaceMouseDebugState.routeCounts = {};
            spaceMouseDebugState.packetCount = 0;
            spaceMouseDebugState.parseErrorCount = 0;
            spaceMouseDebugState.lastPacketAt = 0;
            spaceMouseDebugState.wsMessages = 0;
            spaceMouseDebugState.wsConnected = false;
            if (spaceMouseDebugState.enabled) renderSpaceMouseDebug(true);
        }

        function parseSpaceMouseMotion(kind, data, offset = 0) {
            if (kind === 1 && getByteLength(data) >= offset + 6) {
                const [x, y, z] = readAxisTriplet(data, offset);
                spaceMouseInput.tx = x;
                spaceMouseInput.ty = y;
                spaceMouseInput.tz = z;
                return true;
            }
            if (kind === 2 && getByteLength(data) >= offset + 6) {
                const [x, y, z] = readAxisTriplet(data, offset);
                spaceMouseInput.rx = x;
                spaceMouseInput.ry = y;
                spaceMouseInput.rz = z;
                return true;
            }
            return false;
        }

        function parseSpaceMouseButtons(data, offset = 0) {
            const bytes = getByteLength(data);
            if (!data || bytes < offset + 1) return false;
            const remaining = bytes - offset;
            const mask = remaining >= 2 ? readU16LE(data, offset) : readU8(data, offset);
            spaceMouseInput.buttons = mask;
            handleSpaceMouseButtons(mask);
            return true;
        }

        function onSpaceMouseReport(event) {
            const { data, reportId } = event;
            if (!data) return;
            try {
                spaceMouseInput.lastReportAt = performance.now();
                let parseRoute = 'unparsed';
                let parseKind = '-';
                const bytes = getByteLength(data);

                // SpaceMouse Wireless Receiver sends Report ID 1 with 12 bytes:
                // bytes 0-5 = translation (tx, ty, tz), bytes 6-11 = rotation (rx, ry, rz)
                if (reportId === 1 && bytes >= 12) {
                    const [tx, ty, tz] = readAxisTriplet(data, 0);
                    const [rx, ry, rz] = readAxisTriplet(data, 6);
                    spaceMouseInput.tx = tx;
                    spaceMouseInput.ty = ty;
                    spaceMouseInput.tz = tz;
                    spaceMouseInput.rx = rx;
                    spaceMouseInput.ry = ry;
                    spaceMouseInput.rz = rz;
                    parseRoute = 'report-combined';
                    parseKind = reportId;
                    updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
                    return;
                }
                // Standard separate reports: ID 1 = translation only, ID 2 = rotation only
                if ((reportId === 1 || reportId === 2) && parseSpaceMouseMotion(reportId, data, 0)) {
                    parseRoute = 'report-motion';
                    parseKind = reportId;
                    updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
                    return;
                }
                // Some receivers expose reportId 0 and embed packet type as first byte.
                if (reportId === 0 && bytes >= 2) {
                    const embeddedKind = readU8(data, 0);
                    if (parseSpaceMouseMotion(embeddedKind, data, 1)) {
                        parseRoute = 'embedded-motion';
                        parseKind = embeddedKind;
                        updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
                        return;
                    }
                    if (embeddedKind === 3 && parseSpaceMouseButtons(data, 1)) {
                        parseRoute = 'embedded-buttons';
                        parseKind = embeddedKind;
                        updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
                        return;
                    }
                }

                // Generic packet fallback: [kind][x][y][z]...
                // Keep this before rid=3 button fallback because some devices
                // multiplex motion + buttons on one report ID.
                if (bytes >= 7) {
                    const kind = readU8(data, 0);
                    if (parseSpaceMouseMotion(kind, data, 1)) {
                        parseRoute = 'generic-motion';
                        parseKind = kind;
                        updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
                        return;
                    }
                    if (kind === 3 && parseSpaceMouseButtons(data, 1)) {
                        parseRoute = 'generic-buttons';
                        parseKind = kind;
                        updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
                        return;
                    }
                }

                if (reportId === 3 && parseSpaceMouseButtons(data, 0)) {
                    parseRoute = 'report-buttons';
                    parseKind = 3;
                    updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
                    return;
                }

                // Combined fallback: tx,ty,tz,rx,ry,rz,(buttons?)
                if (bytes >= 12) {
                    const [tx, ty, tz] = readAxisTriplet(data, 0);
                    const [rx, ry, rz] = readAxisTriplet(data, 6);
                    spaceMouseInput.tx = tx;
                    spaceMouseInput.ty = ty;
                    spaceMouseInput.tz = tz;
                    spaceMouseInput.rx = rx;
                    spaceMouseInput.ry = ry;
                    spaceMouseInput.rz = rz;
                    if (bytes >= 13) {
                        parseSpaceMouseButtons(data, 12);
                    }
                    parseRoute = 'combined';
                    parseKind = 'n/a';
                    updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
                    return;
                }
                updateSpaceMouseDebugFromReport(reportId, data, parseRoute, parseKind);
            } catch (err) {
                const detail = err?.message || String(err);
                spaceMouseDebugState.parseErrorCount += 1;
                spaceMouseDebugState.lastError = detail;
                enqueueSpaceMouseLog('parse_error', { detail, reportId });
                updateSpaceMouseUi(`HID parse error: ${detail}`, spaceMouseConnected);
                updateSpaceMouseDebugFromReport(reportId, data, 'parse-error', 'err');
            }
        }

        async function disconnectSpaceMouse(showMessage = true, releaseOwner = true) {
            try {
                clearSpaceMouseNoPacketWatchdog();
                clearSpaceMouseAutoRetryTimer();
                stopSpaceMouseSdkPoll();
                closeSpaceMouseWebSocket();
                if (spaceMouseSdk) {
                    try { spaceMouseSdk.delete3dmouse?.(); } catch (_) {}
                    try { spaceMouseSdk.close?.(); } catch (_) {}
                }
                enqueueSpaceMouseLog('disconnect_begin', {});
                if (Array.isArray(spaceMouseDevices) && spaceMouseDevices.length > 0) {
                    for (const dev of spaceMouseDevices) {
                        if (!dev) continue;
                        dev.removeEventListener('inputreport', onSpaceMouseReport);
                        if (dev.opened) {
                            await dev.close();
                        }
                    }
                } else if (spaceMouseDevice) {
                    spaceMouseDevice.removeEventListener('inputreport', onSpaceMouseReport);
                    if (spaceMouseDevice.opened) await spaceMouseDevice.close();
                }
            } catch (err) {
                console.warn('SpaceMouse disconnect error:', err);
                enqueueSpaceMouseLog('disconnect_error', { detail: err?.message || String(err) });
            } finally {
                spaceMouseDevice = null;
                spaceMouseDevices = [];
                spaceMouseConnected = false;
                spaceMouseProvider = 'none';
                spaceMouseSdk = null;
                spaceMouseSdkClient = null;
                resetSpaceMouseInput();
                if (releaseOwner) {
                    releaseSpaceMouseOwnership('disconnect');
                }
                refreshSpaceMouseDeviceDebugSummary();
                updateSpaceMouseUi(showMessage ? 'Not connected' : '', false);
                enqueueSpaceMouseLog('disconnect_done', {});
                scheduleSpaceMouseAutoRetry('post-disconnect');
            }
        }

        async function openSpaceMouseDevices(devices, options = {}) {
            const armWatchdog = options?.armWatchdog !== false;
            const list = Array.isArray(devices) ? devices.filter(Boolean) : [];
            if (list.length === 0) return false;
            await disconnectSpaceMouse(false, false);
            let opened = 0;
            const openedDevices = [];
            for (const dev of list) {
                try {
                    if (!dev.opened) await dev.open();
                    dev.addEventListener('inputreport', onSpaceMouseReport);
                    opened += 1;
                    openedDevices.push(dev);
                    enqueueSpaceMouseLog('hid_open_ok', {
                        product: dev?.productName || '',
                        vendorId: dev?.vendorId || 0,
                        productId: dev?.productId || 0,
                    });
                } catch (err) {
                    console.warn('SpaceMouse interface open failed:', dev?.productName, err);
                    enqueueSpaceMouseLog('hid_open_fail', {
                        product: dev?.productName || '',
                        detail: err?.message || String(err),
                    });
                }
            }
            if (opened === 0) return false;
            spaceMouseDevices = openedDevices;
            spaceMouseDevice = pickBestSpaceMouseDevice(openedDevices) || openedDevices[0];
            spaceMouseConnected = true;
            spaceMouseProvider = 'webhid';
            spaceMouseNoPacketRecoveryTried = false;
            refreshSpaceMouseDeviceDebugSummary();
            const baseName = (spaceMouseDevice?.productName || 'SpaceMouse');
            updateSpaceMouseUi(`Connected: ${baseName} (${opened} iface)`, true);
            if (armWatchdog) startSpaceMouseNoPacketWatchdog();
            enqueueSpaceMouseLog('hid_connected', { opened, baseName, deviceSummary: spaceMouseDebugState.deviceSummary });
            if (spaceMouseDebugState.enabled) renderSpaceMouseDebug(true);
            return true;
        }

        function startSpaceMouseNoPacketWatchdog() {
            clearSpaceMouseNoPacketWatchdog();
            const baselinePackets = spaceMouseDebugState.packetCount;
            spaceMouseNoPacketTimer = setTimeout(async () => {
                spaceMouseNoPacketTimer = null;
                if (!spaceMouseConnected) return;
                if (spaceMouseDebugState.packetCount > baselinePackets) return;
                if (spaceMouseNoPacketRecoveryTried) return;
                spaceMouseNoPacketRecoveryTried = true;
                updateSpaceMouseUi('Connected but no HID packets; trying 3Dconnexion SDK fallback...', true);
                enqueueSpaceMouseLog('no_packets_fallback', { baselinePackets, mode: 'sdk' });
                const sdkOk = await connectSpaceMouseSdkFallback();
                if (!sdkOk) {
                    updateSpaceMouseUi('SDK fallback failed; trying raw websocket fallback...', true);
                    enqueueSpaceMouseLog('no_packets_fallback', { baselinePackets, mode: 'raw-ws' });
                    await connectSpaceMouseWebSocketFallback();
                }
            }, 2500);
        }

        function uniqueDevicesByKey(devices) {
            const out = [];
            const seen = new Set();
            for (const d of (Array.isArray(devices) ? devices : [])) {
                if (!d) continue;
                const key = `${d.vendorId || 0}:${d.productId || 0}:${d.productName || ''}:${(d.collections || []).length}`;
                if (seen.has(key)) continue;
                seen.add(key);
                out.push(d);
            }
            return out;
        }

        function applySpaceMouseMotionSample(sample) {
            if (!sample || typeof sample !== 'object') return false;
            let changed = false;
            const setAxis = (k, v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return;
                spaceMouseInput[k] = n;
                changed = true;
            };
            setAxis('tx', sample.tx ?? sample.x ?? sample.panX);
            setAxis('ty', sample.ty ?? sample.y ?? sample.panY);
            setAxis('tz', sample.tz ?? sample.z ?? sample.panZ ?? sample.zoom);
            setAxis('rx', sample.rx ?? sample.pitch ?? sample.rotX);
            setAxis('ry', sample.ry ?? sample.yaw ?? sample.rotY);
            setAxis('rz', sample.rz ?? sample.roll ?? sample.rotZ);
            const btn = sample.buttons ?? sample.buttonMask ?? sample.button_state;
            if (Number.isFinite(Number(btn))) {
                const mask = Number(btn) | 0;
                spaceMouseInput.buttons = mask;
                handleSpaceMouseButtons(mask);
                changed = true;
            }
            if (changed) {
                spaceMouseInput.lastReportAt = performance.now();
            }
            return changed;
        }

        function extractSpaceMouseSampleFromPayload(payload) {
            if (!payload) return null;
            if (Array.isArray(payload)) {
                for (const item of payload) {
                    const found = extractSpaceMouseSampleFromPayload(item);
                    if (found) return found;
                }
                return null;
            }
            if (typeof payload === 'object') {
                const keys = Object.keys(payload);
                const hasDirectAxes = ['tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'x', 'y', 'z', 'yaw', 'pitch', 'roll'].some(k => keys.includes(k));
                if (hasDirectAxes) return payload;
                if (Array.isArray(payload.translation) && Array.isArray(payload.rotation)) {
                    return {
                        tx: payload.translation[0],
                        ty: payload.translation[1],
                        tz: payload.translation[2],
                        rx: payload.rotation[0],
                        ry: payload.rotation[1],
                        rz: payload.rotation[2],
                        buttons: payload.buttons,
                    };
                }
                for (const v of Object.values(payload)) {
                    const found = extractSpaceMouseSampleFromPayload(v);
                    if (found) return found;
                }
            }
            return null;
        }

        function openSpaceMouseWebSocket(url, protocols = [], timeoutMs = 1800) {
            return new Promise((resolve, reject) => {
                let done = false;
                let ws;
                try {
                    ws = protocols.length > 0 ? new WebSocket(url, protocols) : new WebSocket(url);
                } catch (err) {
                    reject(err);
                    return;
                }
                const timer = setTimeout(() => {
                    if (done) return;
                    done = true;
                    try { ws.close(); } catch (_) {}
                    reject(new Error(`timeout ${url}`));
                }, timeoutMs);
                ws.onopen = () => {
                    if (done) return;
                    done = true;
                    clearTimeout(timer);
                    resolve(ws);
                };
                ws.onerror = () => {
                    if (done) return;
                    done = true;
                    clearTimeout(timer);
                    reject(new Error(`ws error ${url}`));
                };
                ws.onclose = () => {
                    if (done) return;
                    done = true;
                    clearTimeout(timer);
                    reject(new Error(`ws close ${url}`));
                };
            });
        }

        async function probe3DxNlServer() {
            const probes = [
                { key: 'version', url: 'https://127.51.68.120:8181/version' },
                { key: 'nlproxy', url: 'https://127.51.68.120:8181/3dconnexion/nlproxy' },
            ];
            const out = {};
            for (const p of probes) {
                try {
                    const res = await fetch(p.url, { method: 'GET', cache: 'no-store', mode: 'cors' });
                    let text = '';
                    let json = null;
                    try { text = await res.text(); } catch (_) {}
                    if (text) {
                        try { json = JSON.parse(text); } catch (_) { json = null; }
                    }
                    out[p.key] = {
                        ok: !!res.ok,
                        status: res.status,
                        text: text || '',
                        json,
                    };
                } catch (err) {
                    out[p.key] = {
                        ok: false,
                        status: 0,
                        error: err?.message || String(err),
                    };
                }
            }
            return out;
        }

        function build3DxFallbackHint(probe) {
            const ver = probe?.version || {};
            const nlp = probe?.nlproxy || {};
            const verDown = !ver.ok && (ver.status === 0);
            const certOrPolicy = verDown || (!ver.ok && !nlp.ok);
            if (certOrPolicy) {
                return 'Open https://127.51.68.120:8181/version and accept the 3Dconnexion certificate, then allow Chrome Local Network Access for localhost and reload.';
            }
            if (ver.ok && !nlp.ok) {
                return `3Dx service reachable but nlproxy blocked (status ${nlp.status || 0}). Check firewall/policy and Chrome permissions.`;
            }
            return '3Dx fallback unavailable. Verify 3DxNLServer is running and reachable at 127.51.68.120:8181.';
        }

        function toVec3(value, fallback = [0, 0, 0]) {
            if (Array.isArray(value) && value.length >= 3) {
                const x = Number(value[0]); const y = Number(value[1]); const z = Number(value[2]);
                if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z)) return [x, y, z];
            }
            if (value && typeof value === 'object') {
                const x = Number(value.x); const y = Number(value.y); const z = Number(value.z);
                if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z)) return [x, y, z];
            }
            return fallback;
        }

        function toNumArray(value) {
            if (!value) return null;
            if (Array.isArray(value)) {
                const arr = value.map(Number);
                return arr.every(Number.isFinite) ? arr : null;
            }
            if (ArrayBuffer.isView(value) && typeof value.length === 'number') {
                const arr = Array.from(value, Number);
                return arr.every(Number.isFinite) ? arr : null;
            }
            if (typeof value === 'object') {
                const candidate = value.matrix ?? value.affine ?? value.value ?? value.data;
                if (candidate && candidate !== value) return toNumArray(candidate);
                if (typeof value.length === 'number' && value.length > 0) {
                    try {
                        const arr = Array.from(value, Number);
                        return arr.every(Number.isFinite) ? arr : null;
                    } catch (_) {}
                }
            }
            return null;
        }

        function createSpaceMouseSdkClient() {
            const identity4 = () => new THREE.Matrix4().identity().toArray();
            const defaultExtents6 = () => [-100, -100, -100, 100, 100, 100];
            const viewFrustum6 = () => {
                if (!camera) return [-1, 1, -1, 1, 0.1, 10000];
                const near = Math.max(0.001, Number(camera.near || 0.1));
                const far = Math.max(near + 1, Number(camera.far || 10000));
                const fov = THREE.MathUtils.degToRad(Number(camera.fov || 60));
                const top = Math.tan(fov * 0.5) * near;
                const bottom = -top;
                const aspect = Math.max(0.0001, Number(camera.aspect || 1));
                const right = top * aspect;
                const left = -right;
                return [left, right, bottom, top, near, far];
            };
            const defaults = {
                getViewMatrix: () => camera ? camera.matrixWorld.toArray() : new THREE.Matrix4().toArray(),
                getConstructionPlane: () => [0, 0, 1, 0],
                getViewExtents: () => defaultExtents6(),
                getFov: () => camera ? Number(camera.fov || 60) : 60,
                getViewFrustum: () => viewFrustum6(),
                getPerspective: () => true,
                getViewTarget: () => controls ? [controls.target.x, controls.target.y, controls.target.z] : [0, 0, 0],
                getViewRotatable: () => true,
                getModelExtents: () => defaultExtents6(),
                getFloorPlane: () => [0, 1, 0, 0],
                getUnitsToMeters: () => 1,
                getPivotPosition: () => controls ? [controls.target.x, controls.target.y, controls.target.z] : [0, 0, 0],
                getLookAt: () => controls ? [controls.target.x, controls.target.y, controls.target.z] : [0, 0, 0],
                getSelectionAffine: () => camera ? camera.matrixWorld.toArray() : new THREE.Matrix4().toArray(),
                getSelectionEmpty: () => true,
                getSelectionExtents: () => [0, 0, 0, 0, 0, 0],
                getPointerPosition: () => [0, 0, 0],
                getCoordinateSystem: () => identity4(),
                getFrontView: () => identity4(),
                getFrameTimingSource: () => 0,
                getFrameTime: () => performance.now() / 1000,
                setMoving: (moving) => {
                    enqueueSpaceMouseLog('sdk_moving', { moving: !!moving });
                    return true;
                },
                setTransaction: () => true,
                setViewMatrix: (matrix) => {
                    try {
                        const arr = toNumArray(matrix);
                        if (!arr || arr.length < 16) {
                            enqueueSpaceMouseLog('sdk_set_view_matrix_reject', {
                                reason: 'invalid-matrix',
                                hasValue: !!matrix,
                                matrixType: matrix ? Object.prototype.toString.call(matrix) : 'null',
                                matrixLength: Number(matrix?.length ?? matrix?.matrix?.length ?? matrix?.affine?.length ?? matrix?.value?.length ?? 0),
                            });
                            return false;
                        }
                        if (!camera || !controls) {
                            enqueueSpaceMouseLog('sdk_set_view_matrix_reject', { reason: 'camera-controls-missing' });
                            return false;
                        }
                        const m = new THREE.Matrix4();
                        m.fromArray(arr);
                        const pos = new THREE.Vector3();
                        const quat = new THREE.Quaternion();
                        const scale = new THREE.Vector3();
                        m.decompose(pos, quat, scale);
                        if (!Number.isFinite(pos.x) || !Number.isFinite(pos.y) || !Number.isFinite(pos.z)) {
                            enqueueSpaceMouseLog('sdk_set_view_matrix_reject', { reason: 'non-finite-position' });
                            return false;
                        }
                        camera.position.copy(pos);
                        camera.quaternion.copy(quat);
                        camera.updateMatrixWorld(true);
                        controls.update();
                        // Expose SDK-provided motion in the same debug counters used by WebHID/WS paths.
                        updateSpaceMouseDebugFromReport('sdk', new Float32Array(arr.slice(0, 16)), 'sdk-view-affine', 'sdk');
                        enqueueSpaceMouseLog('sdk_set_view_matrix', {
                            x: Number(pos.x.toFixed(4)),
                            y: Number(pos.y.toFixed(4)),
                            z: Number(pos.z.toFixed(4)),
                        });
                        return true;
                    } catch (err) {
                        enqueueSpaceMouseLog('sdk_set_view_matrix_error', { detail: err?.message || String(err) });
                        return false;
                    }
                },
                setViewExtents: () => true,
                setFov: (fov) => {
                    if (!camera) return false;
                    const n = Number(fov);
                    if (!Number.isFinite(n)) return false;
                    camera.fov = THREE.MathUtils.clamp(n, 10, 120);
                    camera.updateProjectionMatrix();
                    return true;
                },
                setTarget: (tgt) => {
                    if (!controls) return false;
                    const [x, y, z] = toVec3(tgt, [controls.target.x, controls.target.y, controls.target.z]);
                    controls.target.set(x, y, z);
                    controls.update();
                    return true;
                },
                setActiveCommand: () => true,
                setPivotPosition: () => true,
                setPivotVisible: () => true,
                setLookFrom: () => true,
                setLookDirection: () => true,
                setLookAperture: () => true,
                setSelectionOnly: () => true,
                setSelectionAffine: () => true,
                setKeyPress: (k) => {
                    const key = Number(k);
                    if (Number.isFinite(key)) {
                        const bit = key >= 0 && key < 31 ? (1 << key) : 0;
                        if (bit) {
                            const mask = (spaceMouseInput.buttons | 0) | bit;
                            spaceMouseInput.buttons = mask;
                            handleSpaceMouseButtons(mask);
                        }
                    }
                    return true;
                },
                setKeyRelease: (k) => {
                    const key = Number(k);
                    if (Number.isFinite(key)) {
                        const bit = key >= 0 && key < 31 ? (1 << key) : 0;
                        if (bit) {
                            const mask = (spaceMouseInput.buttons | 0) & (~bit);
                            spaceMouseInput.buttons = mask;
                            handleSpaceMouseButtons(mask);
                        }
                    }
                    return true;
                },
                setSettingsChanged: () => true,
            };
            return defaults;
        }

        async function connectSpaceMouseSdkFallback() {
            if (typeof window._3Dconnexion !== 'function') {
                enqueueSpaceMouseLog('sdk_unavailable', {});
                return false;
            }
            if (!ensureSpaceMouseOwnership('sdk_connect')) {
                enqueueSpaceMouseLog('sdk_skip_owner_busy', {});
                return false;
            }
            // Note: SDK can connect even without focus - it will deliver motion once focus is gained.
            // Only log visibility state for diagnostics, don't block connection.
            if (document.hidden) {
                enqueueSpaceMouseLog('sdk_connect_hidden_warning', {
                    hidden: !!document.hidden,
                    hasFocus: !!document.hasFocus(),
                });
                // Continue anyway - SDK will work once tab becomes visible/focused
            }
            try {
                if (spaceMouseSdk && typeof spaceMouseSdk.close === 'function') {
                    try { spaceMouseSdk.close(); } catch (_) {}
                }
                spaceMouseSdkClient = createSpaceMouseSdkClient();
                const sdk = new window._3Dconnexion(spaceMouseSdkClient);
                spaceMouseSdk = sdk;
                sdk.host = '127.51.68.120';
                sdk.defport = 8181;
                enqueueSpaceMouseLog('sdk_connect_begin', { host: sdk.host, defport: sdk.defport });
                if (typeof sdk.onEvent === 'function') {
                    const origOnEvent = sdk.onEvent.bind(sdk);
                    sdk.onEvent = (topicUri, event) => {
                        try {
                            spaceMouseDebugState.sdkMessages += 1;
                            if (spaceMouseDebugState.sdkMessages <= 6 || (spaceMouseDebugState.sdkMessages % SPACEMOUSE_LOG_SAMPLE_EVERY) === 0) {
                                enqueueSpaceMouseLog('sdk_on_event', {
                                    topic: `${topicUri || ''}`,
                                    messageType: Array.isArray(event) ? Number(event[0]) : -1,
                                    proc: Array.isArray(event) ? `${event[2] || ''}` : '-',
                                    prop: Array.isArray(event) ? `${event[4] || ''}` : '-',
                                });
                            }
                        } catch (_) {}
                        return origOnEvent(topicUri, event);
                    };
                }

                const ok = await new Promise((resolve) => {
                    let done = false;
                    const finish = (v) => {
                        if (done) return;
                        done = true;
                        resolve(!!v);
                    };
                    const timer = setTimeout(() => finish(false), 7000);
                    spaceMouseSdkClient.onConnect = () => {
                        enqueueSpaceMouseLog('sdk_on_connect', {});
                        try {
                            const sdkView = renderer?.domElement || window;
                            if (sdkView && sdkView !== window && typeof sdkView.setAttribute === 'function') {
                                sdkView.setAttribute('tabindex', '0');
                                try { sdkView.focus(); } catch (_) {}
                            }
                            enqueueSpaceMouseLog('sdk_create3dmouse', {
                                view: sdkView === window ? 'window' : 'canvas',
                            });
                            sdk.create3dmouse(sdkView, 'PCPRI Neural Walks', window._3Dconnexion?.nlOptions?.none || 0);
                        } catch (err) {
                            enqueueSpaceMouseLog('sdk_create_error', { detail: err?.message || String(err) });
                            clearTimeout(timer);
                            finish(false);
                        }
                    };
                    spaceMouseSdkClient.on3dmouseCreated = () => {
                        enqueueSpaceMouseLog('sdk_on_3dmouse_created', {});
                        focusSpaceMouseSdk('on3dmouseCreated');
                        pushSpaceMouseSdkFocusState('on3dmouseCreated');
                        clearTimeout(timer);
                        finish(true);
                    };
                    spaceMouseSdkClient.onStartMotion = () => {
                        enqueueSpaceMouseLog('sdk_on_start_motion', {});
                    };
                    spaceMouseSdkClient.onStopMotion = () => {
                        enqueueSpaceMouseLog('sdk_on_stop_motion', {});
                    };
                    spaceMouseSdkClient.onDisconnect = (reason) => {
                        enqueueSpaceMouseLog('sdk_disconnect', { reason: `${reason || ''}` });
                        stopSpaceMouseSdkPoll();
                        if (!done) {
                            clearTimeout(timer);
                            finish(false);
                        }
                    };
                    try {
                        sdk.connect();
                    } catch (err) {
                        enqueueSpaceMouseLog('sdk_connect_throw', { detail: err?.message || String(err) });
                        clearTimeout(timer);
                        finish(false);
                    }
                });

                if (!ok) {
                    return false;
                }
                spaceMouseProvider = '3dx-sdk';
                spaceMouseConnected = true;
                updateSpaceMouseUi('Connected via 3Dconnexion SDK', true);
                enqueueSpaceMouseLog('sdk_connected', {});
                focusSpaceMouseSdk('sdk_connected');
                pushSpaceMouseSdkFocusState('sdk_connected');
                if (spaceMouseDebugState.enabled) renderSpaceMouseDebug(true);
                return true;
            } catch (err) {
                enqueueSpaceMouseLog('sdk_fallback_error', { detail: err?.message || String(err) });
                return false;
            }
        }

        async function connectSpaceMouseWebSocketFallback() {
            if (spaceMouseWs && spaceMouseWs.readyState === WebSocket.OPEN) return true;

            // Try to use AutobahnJS (WAMP) if available - this is the proper way
            // to communicate with 3DxNLServer which expects WAMP protocol.
            if (typeof window.ab === 'object' && typeof window.ab.connect === 'function') {
                const wampOk = await connectSpaceMouseWamp();
                if (wampOk) return true;
            }

            // Raw WebSocket fallback - note: this won't receive motion data without
            // WAMP handshake, but may be useful for diagnostics.
            const probe = await probe3DxNlServer();
            const nlPort = Number(probe?.nlproxy?.json?.port);
            const wsPort = Number.isFinite(nlPort) && nlPort > 0 ? nlPort : 8182;
            const candidates = [
                { url: `wss://127.51.68.120:${wsPort}/`, protocols: ['wamp.2.json', 'wamp'] },
                { url: `wss://localhost:${wsPort}/`, protocols: ['wamp.2.json', 'wamp'] },
                { url: `ws://127.51.68.120:${wsPort}/`, protocols: ['wamp.2.json', 'wamp'] },
                { url: `ws://localhost:${wsPort}/`, protocols: ['wamp.2.json', 'wamp'] },
            ];
            for (const c of candidates) {
                try {
                    const ws = await openSpaceMouseWebSocket(c.url, c.protocols, 1500);
                    closeSpaceMouseWebSocket();
                    spaceMouseWs = ws;
                    spaceMouseWsUrl = c.url;
                    spaceMouseProvider = '3dxnl-ws';
                    spaceMouseConnected = true;
                    spaceMouseDebugState.wsConnected = true;
                    updateSpaceMouseUi(`Connected via 3DxNLServer websocket: ${c.url} (no WAMP - limited)`, true);
                    enqueueSpaceMouseLog('ws_connected', { url: c.url, wamp: false });
                    ws.onmessage = (event) => {
                        spaceMouseDebugState.wsMessages += 1;
                        const raw = typeof event.data === 'string' ? event.data : '';
                        let payload = null;
                        if (raw) {
                            try { payload = JSON.parse(raw); } catch (_) { payload = null; }
                        } else if (event.data && typeof event.data === 'object') {
                            payload = event.data;
                        }
                        const sample = extractSpaceMouseSampleFromPayload(payload);
                        if (sample && applySpaceMouseMotionSample(sample)) {
                            updateSpaceMouseDebugFromReport('ws', null, '3dxws-motion', 'ws');
                        } else {
                            updateSpaceMouseDebugFromReport('ws', null, '3dxws-msg', 'ws');
                        }
                    };
                    ws.onerror = () => {
                        spaceMouseDebugState.lastError = `ws error ${spaceMouseWsUrl || c.url}`;
                        enqueueSpaceMouseLog('ws_error', { url: spaceMouseWsUrl || c.url });
                    };
                    ws.onclose = () => {
                        spaceMouseDebugState.wsConnected = false;
                        if (spaceMouseProvider === '3dxnl-ws') {
                            updateSpaceMouseUi('3DxNLServer websocket disconnected', false);
                            spaceMouseConnected = false;
                            spaceMouseProvider = 'none';
                        }
                        enqueueSpaceMouseLog('ws_closed', { url: c.url });
                    };
                    if (spaceMouseDebugState.enabled) renderSpaceMouseDebug(true);
                    return true;
                } catch (err) {
                    const detail = err?.message || String(err);
                    spaceMouseDebugState.lastError = `ws open failed ${c.url}: ${detail}`;
                    enqueueSpaceMouseLog('ws_open_fail', { url: c.url, detail });
                }
            }
            const hint = build3DxFallbackHint(probe);
            const verStatus = probe?.version?.status || 0;
            const nlpStatus = probe?.nlproxy?.status || 0;
            spaceMouseDebugState.lastError = `${spaceMouseDebugState.lastError || 'websocket unavailable'} | version=${verStatus} nlproxy=${nlpStatus}`;
            enqueueSpaceMouseLog('ws_fallback_failed', { verStatus, nlpStatus, hint });
            updateSpaceMouseUi(`WebHID connected but no packets. Websocket fallback failed. ${hint}`, spaceMouseConnected);
            if (spaceMouseDebugState.enabled) renderSpaceMouseDebug(true);
            return false;
        }

        // WAMP-based connection using AutobahnJS (proper 3DxNLServer protocol)
        async function connectSpaceMouseWamp() {
            const probe = await probe3DxNlServer();
            const nlPort = Number(probe?.nlproxy?.json?.port);
            const wsPort = Number.isFinite(nlPort) && nlPort > 0 ? nlPort : 8182;
            const wsUrl = `wss://127.51.68.120:${wsPort}/`;

            return new Promise((resolve) => {
                let resolved = false;
                const finish = (ok) => {
                    if (resolved) return;
                    resolved = true;
                    resolve(ok);
                };

                const timeout = setTimeout(() => finish(false), 5000);

                try {
                    enqueueSpaceMouseLog('wamp_connect_begin', { url: wsUrl });

                    window.ab.connect(wsUrl, (session) => {
                        // Connected successfully
                        clearTimeout(timeout);
                        spaceMouseWampSession = session;
                        spaceMouseProvider = '3dxnl-wamp';
                        spaceMouseConnected = true;
                        spaceMouseDebugState.wsConnected = true;

                        // Set up WAMP prefixes
                        session.prefix('3dx_rpc', 'wss://127.51.68.120/3dconnexion#');
                        session.prefix('3dconnexion', 'wss://127.51.68.120/3dconnexion');

                        updateSpaceMouseUi(`Connected via WAMP: ${wsUrl}`, true);
                        enqueueSpaceMouseLog('wamp_connected', { url: wsUrl });

                        // Subscribe to motion events if available
                        try {
                            session.subscribe('3dconnexion:motion', (topic, event) => {
                                enqueueSpaceMouseLog('wamp_motion', { topic, event: JSON.stringify(event).slice(0, 200) });
                                const sample = extractSpaceMouseSampleFromPayload(event);
                                if (sample && applySpaceMouseMotionSample(sample)) {
                                    updateSpaceMouseDebugFromReport('wamp', null, 'wamp-motion', 'wamp');
                                }
                            });
                        } catch (subErr) {
                            enqueueSpaceMouseLog('wamp_subscribe_error', { detail: subErr?.message || String(subErr) });
                        }

                        finish(true);
                    }, (code, reason) => {
                        // Connection closed/failed
                        clearTimeout(timeout);
                        enqueueSpaceMouseLog('wamp_closed', { code, reason: reason || '' });
                        if (spaceMouseProvider === '3dxnl-wamp') {
                            spaceMouseConnected = false;
                            spaceMouseProvider = 'none';
                            spaceMouseDebugState.wsConnected = false;
                            updateSpaceMouseUi('WAMP connection closed', false);
                        }
                        finish(false);
                    }, { maxRetries: 0, retryDelay: 1000 });
                } catch (err) {
                    clearTimeout(timeout);
                    enqueueSpaceMouseLog('wamp_connect_error', { detail: err?.message || String(err) });
                    finish(false);
                }
            });
        }

        let spaceMouseWampSession = null;

        async function rebindSpaceMouseInterfaces() {
            if (!('hid' in navigator)) return false;
            const current = Array.isArray(spaceMouseDevices) ? spaceMouseDevices.filter(Boolean) : [];
            const first = current[0] || spaceMouseDevice;
            const authorized = await navigator.hid.getDevices();
            const strict = first
                ? authorized.filter(d => d.vendorId === first.vendorId && d.productId === first.productId)
                : [];
            const likely = authorized.filter(isLikelySpaceMouseDevice);
            const merged = uniqueDevicesByKey([...strict, ...likely, ...current]);
            if (merged.length === 0) return false;
            const opened = await openSpaceMouseDevices(merged, { armWatchdog: false });
            if (opened) {
                updateSpaceMouseUi(`Connected: ${(spaceMouseDevice?.productName || 'SpaceMouse')} (${spaceMouseDevices.length} iface, rebound)`, true);
                enqueueSpaceMouseLog('rebind_ok', { ifaceCount: spaceMouseDevices.length });
            }
            return opened;
        }

        function collectionHasUsage(collection, usagePage, usage) {
            if (!collection || typeof collection !== 'object') return false;
            if (collection.usagePage === usagePage && collection.usage === usage) return true;
            const children = Array.isArray(collection.children) ? collection.children : [];
            for (const child of children) {
                if (collectionHasUsage(child, usagePage, usage)) return true;
            }
            return false;
        }

        function isSpaceMouseMotionDevice(device) {
            const cols = Array.isArray(device?.collections) ? device.collections : [];
            for (const c of cols) {
                if (collectionHasUsage(c, 0x01, 0x08)) return true; // Generic Desktop / Multi-axis Controller
            }
            return false;
        }

        function hasKnownSpaceMouseReportIds(device) {
            const cols = Array.isArray(device?.collections) ? device.collections : [];
            for (const c of cols) {
                const reports = Array.isArray(c?.inputReports) ? c.inputReports : [];
                for (const r of reports) {
                    const rid = Number(r?.reportId);
                    if (rid === 0 || rid === 1 || rid === 2 || rid === 3) return true;
                }
                const children = Array.isArray(c?.children) ? c.children : [];
                for (const child of children) {
                    const childReports = Array.isArray(child?.inputReports) ? child.inputReports : [];
                    for (const r of childReports) {
                        const rid = Number(r?.reportId);
                        if (rid === 0 || rid === 1 || rid === 2 || rid === 3) return true;
                    }
                }
            }
            return false;
        }

        function isLikelySpaceMouseDevice(device) {
            if (!device) return false;
            const vendorOk = device.vendorId === 0x256f;
            const name = `${device.productName || ''}`.toLowerCase();
            const nameOk = name.includes('spacemouse') || name.includes('3dconnexion') || name.includes('connexion');
            const motionOk = isSpaceMouseMotionDevice(device);
            return vendorOk || nameOk || motionOk;
        }

        function pickBestSpaceMouseDevice(devices) {
            if (!Array.isArray(devices) || devices.length === 0) return null;
            const knownReports = devices.find(d => isSpaceMouseMotionDevice(d) && hasKnownSpaceMouseReportIds(d));
            if (knownReports) return knownReports;
            const motion = devices.find(isSpaceMouseMotionDevice);
            if (motion) return motion;
            const likely = devices.find(isLikelySpaceMouseDevice);
            if (likely) return likely;
            return devices[0];
        }

        function isTrackedSpaceMouseDevice(device) {
            if (!device) return false;
            if (spaceMouseDevice && device === spaceMouseDevice) return true;
            return Array.isArray(spaceMouseDevices) && spaceMouseDevices.includes(device);
        }

        async function connectSpaceMouse() {
            if (!('hid' in navigator)) {
                updateSpaceMouseUi('WebHID unavailable in this browser context.', false);
                return;
            }
            if (!ensureSpaceMouseOwnership('manual_connect')) {
                updateSpaceMouseUi('SpaceMouse busy in another tab/window', false);
                return;
            }
            try {
                enqueueSpaceMouseLog('connect_begin', {});
                // Prefer already-authorized plugged-in devices first.
                const authorized = await navigator.hid.getDevices();
                const authorizedCandidates = authorized.filter(isLikelySpaceMouseDevice);
                if (authorizedCandidates.length > 0) {
                    const openedAuthorized = await openSpaceMouseDevices(authorizedCandidates);
                    if (openedAuthorized) {
                        await rebindSpaceMouseInterfaces();
                        startSpaceMouseNoPacketWatchdog();
                        return;
                    }
                }

                updateSpaceMouseUi('Waiting for device selection...', false);
                let picked = await navigator.hid.requestDevice({
                    filters: [
                        { vendorId: 0x256f, usagePage: 0x01, usage: 0x08 },
                        { vendorId: 0x256f },
                    ],
                });
                // Fallback: show all HID devices if strict filters don't return anything.
                if (!picked || picked.length === 0) {
                    try {
                        picked = await navigator.hid.requestDevice({ filters: [] });
                    } catch (fallbackErr) {
                        console.warn('SpaceMouse broad picker fallback failed:', fallbackErr);
                    }
                }
                if (!picked || picked.length === 0) {
                    updateSpaceMouseUi('No SpaceMouse selected.', false);
                    enqueueSpaceMouseLog('connect_none_selected', {});
                    return;
                }
                const pickedCandidates = picked.filter(isLikelySpaceMouseDevice);
                const targetDevices = pickedCandidates.length > 0 ? pickedCandidates : picked;
                const openedPicked = await openSpaceMouseDevices(targetDevices);
                if (!openedPicked) {
                    updateSpaceMouseUi('Device selected but could not open HID interface.', false);
                    enqueueSpaceMouseLog('connect_fail_open', {});
                    return;
                }
                await rebindSpaceMouseInterfaces();
                startSpaceMouseNoPacketWatchdog();
            } catch (err) {
                updateSpaceMouseUi(`Connect failed: ${err.message || err}`, false);
                enqueueSpaceMouseLog('connect_error', { detail: err?.message || String(err) });
            }
        }

        async function restoreAuthorizedSpaceMouse() {
            if (!('hid' in navigator)) return;
            if (spaceMouseConnected) return;
            try {
                const devices = await navigator.hid.getDevices();
                const candidates = devices.filter(isLikelySpaceMouseDevice);
                if (candidates.length > 0) {
                    await openSpaceMouseDevices(candidates);
                }
            } catch (err) {
                console.warn('SpaceMouse restore error:', err);
            }
        }

        async function tryAutoConnectSpaceMouse(reason = '') {
            if (!('hid' in navigator)) return;
            if (spaceMouseConnected || spaceMouseAutoConnecting) return;
            spaceMouseAutoConnecting = true;
            try {
                enqueueSpaceMouseLog('auto_connect_try', { reason });
                await restoreAuthorizedSpaceMouse();
                if (!spaceMouseConnected && reason) {
                    updateSpaceMouseUi(`Not connected (${reason})`, false);
                }
            } finally {
                spaceMouseAutoConnecting = false;
            }
        }

        async function autoConnectSpaceMouseAll(reason = 'auto') {
            if (spaceMouseConnected) return;
            if (spaceMouseAutoConnectInFlight) return;
            if (document.hidden) {
                enqueueSpaceMouseLog('auto_connect_all_skip_hidden', { reason });
                scheduleSpaceMouseAutoRetry('auto-retry-visible');
                return;
            }
            if (!ensureSpaceMouseOwnership(`auto_connect:${reason}`)) {
                scheduleSpaceMouseAutoRetry('auto-retry-owner');
                return;
            }
            spaceMouseAutoConnectInFlight = true;
            clearSpaceMouseAutoRetryTimer();
            enqueueSpaceMouseLog('auto_connect_all', { reason });
            try {
                if ('hid' in navigator) {
                    await restoreAuthorizedSpaceMouse();
                }
                if (!spaceMouseConnected) {
                    const sdkOk = await connectSpaceMouseSdkFallback();
                    if (!sdkOk) {
                        await connectSpaceMouseWebSocketFallback();
                    }
                }
            } catch (err) {
                enqueueSpaceMouseLog('auto_connect_all_error', { reason, detail: err?.message || String(err) });
            } finally {
                spaceMouseAutoConnectInFlight = false;
                if (!spaceMouseConnected) {
                    scheduleSpaceMouseAutoRetry('auto-retry');
                }
            }
        }

        function applySpaceMouseInput(deltaSec) {
            if (!spaceMouseConnected || !camera || !controls) return;
            const dt = Math.max(0.001, Math.min(deltaSec, getMotionGain('max_delta_sec', 0.05)));

            // If reports stop, decay to zero to avoid stale drift.
            if (spaceMouseInput.lastReportAt > 0 && (performance.now() - spaceMouseInput.lastReportAt) > 300) {
                spaceMouseInput.tx *= 0.7;
                spaceMouseInput.ty *= 0.7;
                spaceMouseInput.tz *= 0.7;
                spaceMouseInput.rx *= 0.7;
                spaceMouseInput.ry *= 0.7;
                spaceMouseInput.rz *= 0.7;
            }

            const smoothingHz = getMotionGain('input_smoothing_hz', 18.0);
            const alpha = 1 - Math.exp(-dt * smoothingHz);
            const nxRaw = mapSpaceMouseControl('pan_x');
            const nyRaw = mapSpaceMouseControl('pan_y');
            const nzRaw = mapSpaceMouseControl('dolly');
            const nrxRaw = mapSpaceMouseControl('orbit_pitch');
            const nryRaw = mapSpaceMouseControl('orbit_yaw');
            const nrzRaw = mapSpaceMouseControl('roll');

            spaceMouseFiltered.pan_x += (nxRaw - spaceMouseFiltered.pan_x) * alpha;
            spaceMouseFiltered.pan_y += (nyRaw - spaceMouseFiltered.pan_y) * alpha;
            spaceMouseFiltered.dolly += (nzRaw - spaceMouseFiltered.dolly) * alpha;
            spaceMouseFiltered.orbit_pitch += (nrxRaw - spaceMouseFiltered.orbit_pitch) * alpha;
            spaceMouseFiltered.orbit_yaw += (nryRaw - spaceMouseFiltered.orbit_yaw) * alpha;
            spaceMouseFiltered.roll += (nrzRaw - spaceMouseFiltered.roll) * alpha;

            const nx = spaceMouseFiltered.pan_x;
            const ny = spaceMouseFiltered.pan_y;
            const nz = spaceMouseFiltered.dolly;
            const nrx = spaceMouseFiltered.orbit_pitch;
            const nry = spaceMouseFiltered.orbit_yaw;
            const nrz = spaceMouseFiltered.roll;
            const motion = Math.abs(nx) + Math.abs(ny) + Math.abs(nz) + Math.abs(nrx) + Math.abs(nry) + Math.abs(nrz);
            if (motion < 1e-4) return;

            const speed = parseFloat(document.getElementById('spacemouseSpeed')?.value || '1') || 1;
            const panGainK = getMotionGain('pan_gain', 0.25);
            const dollyGainK = getMotionGain('dolly_gain', 0.6);
            const rotateGainK = getMotionGain('rotate_gain', 1.8);
            const rollGainK = getMotionGain('roll_gain', 0.8);
            const maxYawPitch = getMotionGain('max_yaw_pitch_rad_per_frame', 0.09);
            const maxRoll = getMotionGain('max_roll_rad_per_frame', 0.08);
            const viewDir = controls.target.clone().sub(camera.position).normalize();
            const right = new THREE.Vector3().crossVectors(viewDir, camera.up).normalize();
            if (!Number.isFinite(right.x)) {
                right.crossVectors(viewDir, WORLD_UP).normalize();
                if (!Number.isFinite(right.x)) return;
            }
            const up = new THREE.Vector3().crossVectors(right, viewDir).normalize();
            const offset = camera.position.clone().sub(controls.target);
            const dist = Math.max(0.1, offset.length());

            const panGain = dist * panGainK * speed * dt;
            const pan = new THREE.Vector3()
                .addScaledVector(right, nx * panGain)
                .addScaledVector(up, -ny * panGain);
            camera.position.add(pan);
            controls.target.add(pan);

            const dollyGain = dist * dollyGainK * speed * dt;
            camera.position.addScaledVector(viewDir, nz * dollyGain);
            const newDist = camera.position.distanceTo(controls.target);
            if (newDist < 0.5) {
                camera.position.copy(controls.target).addScaledVector(offset.normalize(), 0.5);
            }

            const rotGain = speed * dt * rotateGainK;
            const orbitOffset = camera.position.clone().sub(controls.target);
            const yaw = THREE.MathUtils.clamp(-nry * rotGain, -maxYawPitch, maxYawPitch);
            const pitch = THREE.MathUtils.clamp(-nrx * rotGain, -maxYawPitch, maxYawPitch);
            if (Math.abs(yaw) > 1e-6) {
                orbitOffset.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(up, yaw));
            }
            if (Math.abs(pitch) > 1e-6) {
                const forward = orbitOffset.clone().normalize().negate();
                const pitchAxis = new THREE.Vector3().crossVectors(forward, up).normalize();
                if (Number.isFinite(pitchAxis.x)) {
                    orbitOffset.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(pitchAxis, pitch));
                }
            }
            camera.position.copy(controls.target).add(orbitOffset);

            if (Math.abs(nrz) > 1e-6) {
                const rollAxis = controls.target.clone().sub(camera.position).normalize();
                const rollAmt = THREE.MathUtils.clamp(-nrz * rotGain * rollGainK, -maxRoll, maxRoll);
                camera.up.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(rollAxis, rollAmt)).normalize();
            }

            // Keep camera up stable and orthogonal to view direction to prevent runaway spins.
            const stableViewDir = controls.target.clone().sub(camera.position).normalize();
            const projectedUp = camera.up.clone().projectOnPlane(stableViewDir);
            if (projectedUp.lengthSq() < 1e-10 || !Number.isFinite(projectedUp.x)) {
                const fallbackUp = WORLD_UP.clone().projectOnPlane(stableViewDir);
                if (fallbackUp.lengthSq() > 1e-10 && Number.isFinite(fallbackUp.x)) {
                    camera.up.copy(fallbackUp.normalize());
                } else {
                    camera.up.set(0, 1, 0);
                }
            } else {
                camera.up.copy(projectedUp.normalize());
            }
        }

        function selectLodByDistance(dist) {
            for (const lod of EDGE_LOD_LEVELS) {
                if (dist <= lod.maxDist) return lod;
            }
            return EDGE_LOD_LEVELS[EDGE_LOD_LEVELS.length - 1];
        }

        function updateRendererPixelRatio() {
            const pr = Math.min(window.devicePixelRatio || 1, currentPixelCap);
            renderer.setPixelRatio(pr);
        }

        function rebuildAllEdgesForLod() {
            const thickScale = parseFloat(document.getElementById('thickScale').value);
            const coneScale = parseFloat(document.getElementById('coneScale').value);
            const gamma = parseFloat(document.getElementById('gamma').value);
            for (const walk of Object.values(activeWalks)) {
                scene.remove(walk.edges);
                disposeEdgeObject(walk.edges);
                walk.edges = createEdges(walk.data, walk.color, thickScale, coneScale, gamma, currentEdgeLod);
                scene.add(walk.edges);
            }
        }

        function applyDynamicLod() {
            if (!camera || !controls || !renderer) return;
            const dist = camera.position.distanceTo(controls.target);
            const nextLod = selectLodByDistance(dist);
            if (nextLod.id !== currentEdgeLod.id) {
                currentEdgeLod = nextLod;
                rebuildAllEdgesForLod();
            }
            if (Math.abs(nextLod.pixelCap - currentPixelCap) > 1e-6) {
                currentPixelCap = nextLod.pixelCap;
                updateRendererPixelRatio();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function syncWideLineResolutions() {
            const w = Math.max(1, window.innerWidth);
            const h = Math.max(1, window.innerHeight);
            for (const walk of Object.values(activeWalks)) {
                if (walk?.edges?.isLineSegments2 && walk.edges.material?.resolution) {
                    walk.edges.material.resolution.set(w, h);
                }
            }
        }

        function isEditableElement(target) {
            if (!target || !(target instanceof Element)) return false;
            if (target.isContentEditable) return true;
            const tag = (target.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
            return !!target.closest('input, textarea, select, [contenteditable="true"]');
        }

        function applyUiVisibilityForFullscreen() {
            const hidden = !!document.fullscreenElement;
            document.body.classList.toggle('fullscreen-ui-hidden', hidden);
        }

        async function toggleFullscreenFromKeyboard() {
            if (document.fullscreenElement) {
                await document.exitFullscreen();
                return;
            }
            const root = document.documentElement;
            if (root?.requestFullscreen) {
                try {
                    await root.requestFullscreen({ navigationUI: 'hide' });
                } catch {
                    await root.requestFullscreen();
                }
            }
        }

        function onGlobalKeydown(event) {
            if (event.code !== 'Space') return;
            if (event.repeat) return;
            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey) return;
            if (isEditableElement(event.target)) return;
            event.preventDefault();
            toggleFullscreenFromKeyboard();
        }

        async function init() {
            statusEl = document.getElementById('statusBanner');
            await loadDatasetsFromManifest();
            buildCatalog();
            snapshotOriginalData();
            await loadBase12Index();

            // Default: show original pre-computed walk data (matches thumbnails).
            // Mapping recomputation only happens when user selects a named mapping.

            setStatus('Initializing 3D viewer...');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(100, 100, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateRendererPixelRatio();
            document.getElementById('container').appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));

            // Grid on XY plane
            gridHelper = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);

            // Axes
            const axisLen = 100;
            addAxis(0, axisLen, 0xff4444, 'X');
            addAxis(1, axisLen, 0x44ff44, 'Y');
            addAxis(2, axisLen, 0x4444ff, 'Z');

            // Build checkboxes
            buildCheckboxes();
            clearStatus();

            // Event listeners
            document.getElementById('sizeScale').addEventListener('input', updateAllWalks);
            document.getElementById('thickScale').addEventListener('input', updateAllWalks);
            document.getElementById('coneScale').addEventListener('input', updateAllWalks);
            document.getElementById('edgeMode').addEventListener('change', onEdgeModeChange);
            document.getElementById('gamma').addEventListener('input', updateAllWalks);
            document.getElementById('downsampleLimit').addEventListener('input', updateDownsampleLabel);
            document.getElementById('downsampleLimit').addEventListener('change', applyDownsampleLimit);
            document.getElementById('mappingSelect').addEventListener('change', onMappingChange);
            document.getElementById('walkSearch').addEventListener('input', filterWalkList);
            document.getElementById('centerBtn').addEventListener('click', centerCamera);
            document.getElementById('saveViewBtn').addEventListener('click', saveCurrentView);
            document.getElementById('loadViewBtn').addEventListener('click', loadSelectedView);
            document.getElementById('deleteViewBtn').addEventListener('click', deleteSelectedView);
            document.getElementById('toggleGrid').addEventListener('change', onToggleHelpers);
            document.getElementById('toggleAxes').addEventListener('change', onToggleHelpers);
            document.getElementById('spacemouseConnectBtn').addEventListener('click', connectSpaceMouse);
            document.getElementById('spacemouseDisconnectBtn').addEventListener('click', () => disconnectSpaceMouse(true));
            document.getElementById('spacemouseReloadBtn').addEventListener('click', () => {
                reloadSpaceMouseMappingFromYaml();
            });
            document.getElementById('spacemouseSpeed').addEventListener('input', () => {
                document.getElementById('spacemouseSpeedVal').textContent = document.getElementById('spacemouseSpeed').value;
            });
            document.getElementById('spacemouseDebugToggle').addEventListener('change', onSpaceMouseDebugToggle);
            setupAxisConfigListeners();
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onGlobalKeydown);
            window.addEventListener('focus', () => {
                if (spaceMouseProvider === '3dx-sdk') {
                    focusSpaceMouseSdk('window_focus');
                } else if (!document.hidden) {
                    autoConnectSpaceMouseAll('window_focus');
                }
            });
            window.addEventListener('storage', (event) => {
                if (event.key !== SPACEMOUSE_OWNER_KEY) return;
                const owner = readSpaceMouseOwner();
                const mine = owner && owner.id === spaceMouseTabId;
                if (!mine && spaceMouseConnected) {
                    enqueueSpaceMouseLog('owner_lost_disconnect', { ownerId: owner?.id || '' });
                    disconnectSpaceMouse(false, true);
                }
            });
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    if (spaceMouseProvider === '3dx-sdk') {
                        blurSpaceMouseSdk('visibility_hidden');
                        disconnectSpaceMouse(false, true);
                    }
                    return;
                }
                if (spaceMouseProvider === '3dx-sdk') {
                    focusSpaceMouseSdk('visibility_visible');
                } else {
                    autoConnectSpaceMouseAll('visibility_visible');
                }
            });
            window.addEventListener('beforeunload', () => {
                flushSpaceMouseLogs(true);
                releaseSpaceMouseOwnership('beforeunload');
            });
            document.addEventListener('fullscreenchange', applyUiVisibilityForFullscreen);
            enqueueSpaceMouseLog('page_init', { href: window.location.href });
            if ('hid' in navigator) {
                navigator.hid.addEventListener('disconnect', (event) => {
                    if (isTrackedSpaceMouseDevice(event.device)) {
                        disconnectSpaceMouse(true);
                    }
                });
                navigator.hid.addEventListener('connect', (event) => {
                    if (isLikelySpaceMouseDevice(event.device)) {
                        autoConnectSpaceMouseAll('device connected');
                    }
                });
                updateSpaceMouseUi('Not connected', false);
                autoConnectSpaceMouseAll('startup');
            } else {
                updateSpaceMouseUi('WebHID unavailable in this browser context.', false);
                autoConnectSpaceMouseAll('startup-no-hid');
            }
            reloadSpaceMouseMappingFromYaml();
            loadSavedViewsFromStorage();
            rebuildSavedViewsSelect();
            filterWalkList();
            applyUiVisibilityForFullscreen();

            animate();
        }

        function captureCurrentViewState() {
            if (!camera || !controls) return null;
            return {
                camera: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z,
                },
                target: {
                    x: controls.target.x,
                    y: controls.target.y,
                    z: controls.target.z,
                },
                selectedWalks: getSelectedWalkIds(),
                controls: captureControlState(),
            };
        }

        function applyViewState(state) {
            if (!state || !camera || !controls) return false;
            if (state.controls && typeof state.controls === 'object') {
                applyControlState(state.controls);
            }
            const cp = state.camera || {};
            const tp = state.target || {};
            const nums = [cp.x, cp.y, cp.z, tp.x, tp.y, tp.z].map(Number);
            if (nums.some(v => !Number.isFinite(v))) return false;
            camera.position.set(nums[0], nums[1], nums[2]);
            controls.target.set(nums[3], nums[4], nums[5]);
            controls.update();
            if (Array.isArray(state.selectedWalks)) {
                applySelectedWalks(state.selectedWalks);
            }
            return true;
        }

        function captureControlState() {
            return {
                sizeScale: document.getElementById('sizeScale')?.value,
                thickScale: document.getElementById('thickScale')?.value,
                coneScale: document.getElementById('coneScale')?.value,
                gamma: document.getElementById('gamma')?.value,
                downsampleLimit: document.getElementById('downsampleLimit')?.value,
                edgeMode: document.getElementById('edgeMode')?.value,
                toggleGrid: !!document.getElementById('toggleGrid')?.checked,
                toggleAxes: !!document.getElementById('toggleAxes')?.checked,
                spacemouseSpeed: document.getElementById('spacemouseSpeed')?.value,
                spacemouseDebug: !!document.getElementById('spacemouseDebugToggle')?.checked,
            };
        }

        function setControlValue(id, value) {
            const el = document.getElementById(id);
            if (!el || value === undefined || value === null) return false;
            const prev = el.value;
            el.value = String(value);
            return prev !== el.value;
        }

        function setControlChecked(id, checked) {
            const el = document.getElementById(id);
            if (!el || typeof checked !== 'boolean') return false;
            const changed = el.checked !== checked;
            el.checked = checked;
            return changed;
        }

        function applyControlState(state) {
            let needsWalkRebuild = false;
            let downsampleChanged = false;

            needsWalkRebuild = setControlValue('sizeScale', state.sizeScale) || needsWalkRebuild;
            needsWalkRebuild = setControlValue('thickScale', state.thickScale) || needsWalkRebuild;
            needsWalkRebuild = setControlValue('coneScale', state.coneScale) || needsWalkRebuild;
            needsWalkRebuild = setControlValue('gamma', state.gamma) || needsWalkRebuild;
            downsampleChanged = setControlValue('downsampleLimit', state.downsampleLimit) || downsampleChanged;
            needsWalkRebuild = setControlValue('edgeMode', state.edgeMode) || needsWalkRebuild;
            setControlValue('spacemouseSpeed', state.spacemouseSpeed);
            document.getElementById('spacemouseSpeedVal').textContent = document.getElementById('spacemouseSpeed')?.value || '1.0';

            setControlChecked('toggleGrid', !!state.toggleGrid);
            setControlChecked('toggleAxes', !!state.toggleAxes);
            onToggleHelpers();

            if (typeof state.spacemouseDebug === 'boolean') {
                setControlChecked('spacemouseDebugToggle', state.spacemouseDebug);
                onSpaceMouseDebugToggle();
            }

            edgeRenderMode = document.getElementById('edgeMode')?.value || 'auto';
            updateDownsampleLabel();

            if (downsampleChanged) {
                maxRemappedSteps = parseInt(document.getElementById('downsampleLimit').value, 10) || 30000;
                for (const key of Object.keys(walkDataCache)) delete walkDataCache[key];
                needsWalkRebuild = true;
            }

            if (needsWalkRebuild) {
                updateAllWalks();
            } else {
                document.getElementById('sizeVal').textContent = document.getElementById('sizeScale').value;
                document.getElementById('thickVal').textContent = document.getElementById('thickScale').value;
                document.getElementById('coneVal').textContent = document.getElementById('coneScale').value;
                document.getElementById('gammaVal').textContent = document.getElementById('gamma').value;
            }
        }

        function getSelectedWalkIds() {
            const ids = [];
            document.querySelectorAll('#walkToggles input[type="checkbox"][data-walk]').forEach((cb) => {
                if (cb.checked) ids.push(cb.dataset.walk);
            });
            return ids;
        }

        function applySelectedWalks(selectedIds) {
            const valid = new Set(selectedIds.filter(id => !!walkDataById[id]));
            beginPlottingStatus('Plotting Data...');

            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const checkboxes = document.querySelectorAll('#walkToggles input[type="checkbox"][data-walk]');
                    checkboxes.forEach((cb) => {
                        const id = cb.dataset.walk;
                        const shouldBeChecked = valid.has(id);
                        if (cb.checked === shouldBeChecked) return;
                        cb.checked = shouldBeChecked;
                        if (shouldBeChecked) {
                            addWalkImmediate(id);
                        } else {
                            pendingAddTokens.delete(id);
                            removeWalk(id);
                        }
                    });
                    endPlottingStatus();
                });
            });
        }

        function loadSavedViewsFromStorage() {
            try {
                const raw = localStorage.getItem(SAVED_VIEWS_KEY);
                if (!raw) {
                    savedViews = {};
                    return;
                }
                const parsed = JSON.parse(raw);
                savedViews = (parsed && typeof parsed === 'object') ? parsed : {};
            } catch (err) {
                console.warn('Failed loading saved views:', err);
                savedViews = {};
            }
        }

        function persistSavedViews() {
            try {
                localStorage.setItem(SAVED_VIEWS_KEY, JSON.stringify(savedViews));
            } catch (err) {
                console.warn('Failed saving views:', err);
            }
        }

        function rebuildSavedViewsSelect() {
            const select = document.getElementById('viewList');
            if (!select) return;
            const current = select.value;
            select.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select view...';
            select.appendChild(placeholder);

            const names = Object.keys(savedViews).sort((a, b) => a.localeCompare(b));
            for (const name of names) {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                select.appendChild(opt);
            }
            if (current && savedViews[current]) select.value = current;
        }

        function saveCurrentView() {
            const input = document.getElementById('viewName');
            const name = (input?.value || '').trim();
            if (!name) {
                setStatus('Enter a view name before saving.');
                return;
            }
            const state = captureCurrentViewState();
            if (!state) return;
            savedViews[name] = state;
            persistSavedViews();
            rebuildSavedViewsSelect();
            const select = document.getElementById('viewList');
            if (select) select.value = name;
            setStatus(`Saved view: ${name}`);
            setTimeout(clearStatus, 700);
        }

        function loadSelectedView() {
            const select = document.getElementById('viewList');
            const name = select?.value || '';
            if (!name || !savedViews[name]) {
                setStatus('Select a saved view to load.');
                return;
            }
            if (applyViewState(savedViews[name])) {
                setStatus(`Loaded view: ${name}`);
                setTimeout(clearStatus, 700);
            }
        }

        function deleteSelectedView() {
            const select = document.getElementById('viewList');
            const name = select?.value || '';
            if (!name || !savedViews[name]) {
                setStatus('Select a saved view to delete.');
                return;
            }
            delete savedViews[name];
            persistSavedViews();
            rebuildSavedViewsSelect();
            setStatus(`Deleted view: ${name}`);
            setTimeout(clearStatus, 700);
        }

        function addAxis(axis, len, color, label) {
            const points = [new THREE.Vector3(), new THREE.Vector3()];
            points[1].setComponent(axis, len);
            const line = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points),
                new THREE.LineBasicMaterial({ color })
            );
            scene.add(line);
            axisObjects.push(line);

            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.font = 'bold 48px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 32, 32);

            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.scale.set(8, 8, 1);
            sprite.position.setComponent(axis, len + 5);
            scene.add(sprite);
            axisObjects.push(sprite);
        }

        function onToggleHelpers() {
            const showGrid = !!document.getElementById('toggleGrid')?.checked;
            const showAxes = !!document.getElementById('toggleAxes')?.checked;
            if (gridHelper) gridHelper.visible = showGrid;
            for (const obj of axisObjects) obj.visible = showAxes;
        }

        function onEdgeModeChange() {
            edgeRenderMode = document.getElementById('edgeMode')?.value || 'auto';
            rebuildAllEdgesForLod();
        }

        function buildCheckboxes() {
            const container = document.getElementById('walkToggles');
            container.innerHTML = '';

            walkOptions.forEach(group => {
                const groupBlock = document.createElement('div');
                groupBlock.className = 'group-block';

                const header = document.createElement('div');
                header.className = 'group-header';
                header.textContent = group.group;
                groupBlock.appendChild(header);

                group.subgroups.forEach(subgroup => {
                    const subgroupBlock = document.createElement('div');
                    subgroupBlock.className = 'subgroup-block';

                    const subgroupHeader = document.createElement('div');
                    subgroupHeader.className = 'subgroup-header';
                    subgroupHeader.textContent = subgroup.subgroup;
                    subgroupBlock.appendChild(subgroupHeader);

                    subgroup.items.forEach(item => {
                        const toggle = document.createElement('label');
                        toggle.className = 'walk-toggle';
                        toggle.dataset.label = item.label.toLowerCase();

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.dataset.walk = item.value;
                        checkbox.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                addWalk(item.value);
                            } else {
                                pendingAddTokens.delete(item.value);
                                removeWalk(item.value);
                            }
                        });

                        const swatch = document.createElement('div');
                        swatch.className = 'color-swatch';
                        swatch.style.backgroundColor = '#' + WALK_COLORS[item.value].toString(16).padStart(6, '0');

                        const labelText = document.createElement('span');
                        labelText.textContent = item.label;

                        toggle.appendChild(checkbox);
                        toggle.appendChild(swatch);
                        toggle.appendChild(labelText);
                        subgroupBlock.appendChild(toggle);
                    });

                    groupBlock.appendChild(subgroupBlock);
                });

                container.appendChild(groupBlock);
            });
        }

        function filterWalkList() {
            const q = (document.getElementById('walkSearch').value || '').trim().toLowerCase();
            const groupBlocks = document.querySelectorAll('.group-block');

            groupBlocks.forEach(groupBlock => {
                const subgroupBlocks = groupBlock.querySelectorAll('.subgroup-block');
                let visibleSubgroups = 0;

                subgroupBlocks.forEach(subgroupBlock => {
                    const toggles = subgroupBlock.querySelectorAll('.walk-toggle');
                    let visibleItems = 0;

                    toggles.forEach(toggle => {
                        const label = toggle.dataset.label || '';
                        const visible = q.length === 0 || label.includes(q);
                        toggle.style.display = visible ? 'flex' : 'none';
                        if (visible) visibleItems += 1;
                    });

                    subgroupBlock.style.display = visibleItems > 0 ? 'block' : 'none';
                    if (visibleItems > 0) visibleSubgroups += 1;
                });

                groupBlock.style.display = visibleSubgroups > 0 ? 'block' : 'none';
            });
        }

        function heatColor(t, gamma, baseColor) {
            t = Math.pow(t, gamma);
            // Rainbow ramp: low revisit -> blue, high revisit -> red.
            const hue = (1.0 - t) * 0.75; // 0.75(violet) .. 0(red)
            const c = new THREE.Color();
            c.setHSL(hue, 0.95, 0.52);
            return c;
        }

        function addWalk(walkName) {
            if (activeWalks[walkName]) return;
            const token = addTokenCounter++;
            pendingAddTokens.set(walkName, token);
            beginPlottingStatus(`Plotting Data: ${walkInfoById[walkName]?.label || walkName}...`);

            // Let checkbox/state paint first, then guarantee a frame for status paint,
            // then do heavy plotting work.
            requestAnimationFrame(() => {
                const stillPending = pendingAddTokens.get(walkName) === token;
                const checkbox = document.querySelector(`input[data-walk="${walkName}"]`);
                const stillChecked = !!checkbox && checkbox.checked;
                if (!stillPending || !stillChecked) return;
                requestAnimationFrame(() => {
                    const pending2 = pendingAddTokens.get(walkName) === token;
                    const checkbox2 = document.querySelector(`input[data-walk="${walkName}"]`);
                    const checked2 = !!checkbox2 && checkbox2.checked;
                    if (!pending2 || !checked2) {
                        endPlottingStatus();
                        return;
                    }
                    addWalkImmediate(walkName);
                    pendingAddTokens.delete(walkName);
                    endPlottingStatus();
                });
            });
        }

        function addWalkImmediate(walkName) {
            if (activeWalks[walkName]) return;

            let data = walkDataCache[walkName];
            if (!data) {
                const raw = walkDataById[walkName];
                data = raw ? normalizePath(raw.path) : null;
                if (data) walkDataCache[walkName] = data;
            }
            if (!data || !data.points || data.points.length === 0) {
                console.error('No data for walk:', walkName);
                return;
            }

            const color = WALK_COLORS[walkName];
            const sizeScale = parseFloat(document.getElementById('sizeScale').value);
            const thickScale = parseFloat(document.getElementById('thickScale').value);
            const coneScale = parseFloat(document.getElementById('coneScale').value);
            const gamma = parseFloat(document.getElementById('gamma').value);

            // Create points
            const points = createPoints(data, color, sizeScale, gamma);
            scene.add(points);

            // Create edges
            const edges = createEdges(data, color, thickScale, coneScale, gamma, currentEdgeLod);
            scene.add(edges);

            activeWalks[walkName] = { points, edges, data, color };
            updateLegend();
        }

        function removeWalk(walkName) {
            const walk = activeWalks[walkName];
            if (!walk) return;

            scene.remove(walk.points);
            scene.remove(walk.edges);
            walk.points.geometry.dispose();
            walk.points.material.dispose();
            disposeEdgeObject(walk.edges);

            delete activeWalks[walkName];
            updateLegend();
        }

        function disposeEdgeObject(obj) {
            if (!obj) return;
            obj.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }

        function createPoints(data, baseColor, sizeScale, gamma) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const maxVisits = data.maxPointVisits;

            for (const p of data.points) {
                positions.push(p.x, p.y, p.z);
                const t = p.v / maxVisits;
                const color = heatColor(t, gamma, baseColor);
                colors.push(color.r, color.g, color.b);
                sizes.push((0.3 + Math.pow(t, 0.8) * 2.5) * sizeScale);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (150.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        float d = length(gl_PointCoord - vec2(0.5));
                        if (d > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.0, 0.5, d);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            });

            return new THREE.Points(geometry, material);
        }

        function edgeAdaptiveStride(data, lod) {
            let stride = Math.max(1, lod.stride || 1);
            if (!camera || !renderer || !controls || !data?.avgStepLen || data.avgStepLen <= 0) return stride;

            const dist = camera.position.distanceTo(controls.target);
            const fovRad = THREE.MathUtils.degToRad(camera.fov);
            const worldHeight = 2 * Math.tan(fovRad / 2) * dist;
            const viewHeight = Math.max(1, renderer.domElement.clientHeight || window.innerHeight);
            const worldPerPixel = worldHeight / viewHeight;
            const minWorldStep = worldPerPixel * TARGET_EDGE_PIXEL_STEP;
            const strideByPixels = Math.ceil(minWorldStep / data.avgStepLen);
            if (Number.isFinite(strideByPixels) && strideByPixels > stride) {
                stride = strideByPixels;
            }
            return Math.max(1, stride);
        }

        function createEdges(data, baseColor, thickScale, coneScale, gamma, lod = currentEdgeLod) {
            const stride = edgeAdaptiveStride(data, lod);
            const estimatedSegments = Math.ceil(Math.max(0, data.points.length - 1) / stride);
            if (edgeRenderMode === 'lines') {
                return createLineEdges(data, baseColor, thickScale, coneScale, gamma, stride);
            }
            if (edgeRenderMode === 'cones') {
                return createConeEdges(data, baseColor, thickScale, coneScale, gamma, lod, stride);
            }
            const useCones = lod.id <= 1 && estimatedSegments <= MAX_CONE_SEGMENTS;
            return useCones
                ? createConeEdges(data, baseColor, thickScale, coneScale, gamma, lod, stride)
                : createLineEdges(data, baseColor, thickScale, coneScale, gamma, stride);
        }

        function createLineEdges(data, baseColor, thickScale, coneScale, gamma, stride) {
            const positions = [];
            const colors = [];
            const maxVisits = data.maxPointVisits;
            const start = new THREE.Vector3();
            const end = new THREE.Vector3();
            const dir = new THREE.Vector3();
            const lastDir = new THREE.Vector3(1, 0, 0);
            const dwellLen = 0.06;

            for (let i = 0; i < data.points.length - 1; i += stride) {
                const j = Math.min(i + stride, data.points.length - 1);
                const p0 = data.points[i];
                const p1 = data.points[j];
                start.set(p0.x, p0.y, p0.z);
                end.set(p1.x, p1.y, p1.z);
                dir.subVectors(end, start);
                if (dir.lengthSq() < 1e-12) {
                    end.copy(start).addScaledVector(lastDir, dwellLen);
                } else {
                    dir.normalize();
                    lastDir.copy(dir);
                }

                const t1 = Math.max(0, Math.min(1, p1.v / maxVisits));
                const c = heatColor(t1, gamma, baseColor);
                positions.push(start.x, start.y, start.z, end.x, end.y, end.z);
                colors.push(c.r, c.g, c.b, c.r, c.g, c.b);
            }

            const geometry = new LineSegmentsGeometry();
            geometry.setPositions(positions);
            geometry.setColors(colors);
            const material = new LineMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                depthWrite: false,
                linewidth: Math.max(1, thickScale * Math.max(0.6, coneScale / 2)),
            });
            material.resolution.set(Math.max(1, window.innerWidth), Math.max(1, window.innerHeight));
            const line = new LineSegments2(geometry, material);
            line.computeLineDistances();
            return line;
        }

        function createConeEdges(data, baseColor, thickScale, coneScale, gamma, lod = currentEdgeLod, stride = 1) {
            const group = new THREE.Group();
            const up = new THREE.Vector3(0, 1, 0);
            const start = new THREE.Vector3();
            const end = new THREE.Vector3();
            const dir = new THREE.Vector3();
            const mid = new THREE.Vector3();
            const lastDir = new THREE.Vector3(1, 0, 0);
            const maxVisits = data.maxPointVisits;
            const radialSegments = lod.radialSegments;
            const dwellLen = 0.06 * Math.max(0.5, thickScale / 3);

            for (let i = 0; i < data.points.length - 1; i += stride) {
                const j = Math.min(i + stride, data.points.length - 1);
                const p0 = data.points[i];
                const p1 = data.points[j];

                start.set(p0.x, p0.y, p0.z);
                end.set(p1.x, p1.y, p1.z);
                dir.subVectors(end, start);
                let len = dir.length();
                if (len < 1e-6) {
                    dir.copy(lastDir).normalize();
                    len = dwellLen;
                    end.copy(start).addScaledVector(dir, len);
                } else {
                    dir.divideScalar(len);
                    lastDir.copy(dir);
                }

                const t0 = Math.max(0, Math.min(1, p0.v / maxVisits));
                const t1 = Math.max(0, Math.min(1, p1.v / maxVisits));
                const coneMul = Math.max(0.25, coneScale / 3);
                const radiusStart = (0.02 + Math.pow(t0, 0.9) * 0.18) * (thickScale / 3) * coneMul;
                const radiusEnd = (0.02 + Math.pow(t1, 0.9) * 0.18) * (thickScale / 3) * coneMul;

                const geometry = new THREE.CylinderGeometry(radiusEnd, radiusStart, len, radialSegments, 1, true);
                const color = heatColor(t1, gamma, baseColor);
                const material = new THREE.MeshBasicMaterial({
                    color,
                    transparent: true,
                    opacity: 0.65,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.quaternion.setFromUnitVectors(up, dir);
                mid.copy(start).add(end).multiplyScalar(0.5);
                mesh.position.copy(mid);
                group.add(mesh);
            }

            return group;
        }

        function updateAllWalks() {
            document.getElementById('sizeVal').textContent = document.getElementById('sizeScale').value;
            document.getElementById('thickVal').textContent = document.getElementById('thickScale').value;
            document.getElementById('coneVal').textContent = document.getElementById('coneScale').value;
            document.getElementById('gammaVal').textContent = document.getElementById('gamma').value;

            const walkNames = Object.keys(activeWalks);
            walkNames.forEach(name => {
                removeWalk(name);
                // Re-check the checkbox to trigger addWalk
                const checkbox = document.querySelector(`input[data-walk="${name}"]`);
                if (checkbox) {
                    addWalkImmediate(name);
                }
            });
        }

        function updateDownsampleLabel() {
            document.getElementById('dsVal').textContent = document.getElementById('downsampleLimit').value;
        }

        function applyDownsampleLimit() {
            maxRemappedSteps = parseInt(document.getElementById('downsampleLimit').value, 10) || 30000;
            updateDownsampleLabel();

            // Force remap with new limit.
            for (const key of Object.keys(walkDataCache)) delete walkDataCache[key];
            updateAllWalks();
        }

        function onMappingChange() {
            const sel = document.getElementById('mappingSelect');
            const newMapping = sel.value;
            if (newMapping === currentMappingName) return;
            currentMappingName = newMapping;

            const activeCount = Object.keys(activeWalks).length;

            if (newMapping === 'Original') {
                // Revert to original pre-computed points (matches thumbnails)
                for (const key of Object.keys(walkDataCache)) delete walkDataCache[key];
                for (const [id, orig] of Object.entries(originalWalkData)) {
                    walkDataById[id] = { path: orig.path.slice() };
                }
                reAddActiveWalks();
                if (activeCount > 0) {
                    setStatus(`Reverted ${activeCount} walk(s) to original mapping`, true);
                } else {
                    setStatus('Mapping set to Original. Select walks to see the effect.', true);
                }
                console.log(`Reverted to Original mapping (${activeCount} active walks)`);
                return;
            }

            if (!base12Index) {
                setStatus('Base12 index not loaded — cannot change mapping. Try refreshing the page.', true);
                sel.value = 'Original';
                currentMappingName = 'Original';
                return;
            }

            const mapping = NAMED_MAPPINGS[newMapping];
            if (!mapping) return;

            beginPlottingStatus(`Recomputing walks with ${newMapping} mapping...`);

            requestAnimationFrame(() => {
                let recomputed = 0;
                for (const id of Object.keys(walkDataById)) {
                    const newPath = recomputeWalkPoints(id, mapping);
                    if (newPath) {
                        walkDataById[id] = { path: newPath };
                        recomputed++;
                    }
                }
                for (const key of Object.keys(walkDataCache)) delete walkDataCache[key];
                reAddActiveWalks();
                endPlottingStatus();

                if (activeCount > 0) {
                    setStatus(`Applied ${newMapping} mapping to ${activeCount} displayed walk(s)`, true);
                } else {
                    setStatus(`Mapping set to ${newMapping}. Select walks from the panel to see the effect.`, true);
                }
                console.log(`Recomputed ${recomputed}/${Object.keys(walkDataById).length} walks with ${newMapping} mapping (${activeCount} active)`);
            });
        }

        // Store original walk data for reverting
        const originalWalkData = {};

        function snapshotOriginalData() {
            for (const [id, data] of Object.entries(walkDataById)) {
                originalWalkData[id] = { path: data.path.slice() };
            }
        }

        function reAddActiveWalks() {
            const activeIds = Object.keys(activeWalks);
            for (const id of activeIds) {
                removeWalk(id);
            }
            for (const id of activeIds) {
                addWalkImmediate(id);
            }
        }

        function updateLegend() {
            const container = document.getElementById('legendItems');
            const walks = Object.entries(activeWalks);

            if (walks.length === 0) {
                container.innerHTML = '<span style="color:#666">None selected</span>';
                return;
            }

            container.innerHTML = '';
            for (const [walkName, walk] of walks) {
                const info = walkInfoById[walkName];
                if (!info) continue;

                const item = document.createElement('div');
                item.className = 'legend-item';

                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = '#' + walk.color.toString(16).padStart(6, '0');

                const text = document.createElement('div');
                text.innerHTML = `<div>${info.label}</div><div class="legend-stats">Revisit: ${(walk.data.revisitRatio * 100).toFixed(1)}%</div>`;

                item.appendChild(colorBox);
                item.appendChild(text);
                container.appendChild(item);
            }
        }

        function centerCamera() {
            const box = new THREE.Box3();
            let hasContent = false;

            for (const walk of Object.values(activeWalks)) {
                box.expandByObject(walk.points);
                hasContent = true;
            }

            if (hasContent) {
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                controls.target.copy(center);
                camera.position.set(center.x + maxDim, center.y + maxDim * 0.5, center.z + maxDim);
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            updateRendererPixelRatio();
            renderer.setSize(window.innerWidth, window.innerHeight);
            syncWideLineResolutions();
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const deltaSec = Math.min(0.05, Math.max(0.001, (now - lastFrameTs) / 1000));
            lastFrameTs = now;
            applySpaceMouseInput(deltaSec);
            controls.update();
            frameCounter += 1;
            if ((frameCounter % 8) === 0) {
                applyDynamicLod();
                updateAxisValueDisplays();
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
