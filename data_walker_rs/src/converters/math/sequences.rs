//! Mathematical Sequences - Deterministic integer sequences to base-12
//!
//! - Fibonacci word: aperiodic binary sequence
//! - Thue-Morse: self-similar binary sequence
//! - Logistic map: chaotic dynamical system

/// Fibonacci Word
///
/// Generated by: a_1 = 1, a_2 = 0, a_n = a_{n-1} + a_{n-2} (concatenation)
/// Produces: 0, 01, 010, 01001, 01001010, ...
/// Mapped to base-12 by grouping bits
pub fn fibonacci_word(length: usize) -> Vec<u8> {
    if length == 0 {
        return vec![];
    }

    // Generate Fibonacci word bits
    let mut a = vec![0u8];
    let mut b = vec![0u8, 1u8];

    while b.len() < length * 4 {
        let next: Vec<u8> = b.iter().chain(a.iter()).copied().collect();
        a = b;
        b = next;
    }

    // Convert bits to base-12 (every ~3.58 bits = 1 base-12 digit)
    // Use 4 bits → map to 0-11 with wrap
    let mut result = Vec::with_capacity(length);
    for chunk in b.chunks(4) {
        if result.len() >= length {
            break;
        }
        let val: u8 = chunk.iter().enumerate()
            .map(|(i, &bit)| bit << i)
            .sum();
        result.push(val % 12);
    }

    result.truncate(length);
    result
}

/// Thue-Morse Sequence
///
/// Generated by: start with 0, repeatedly append complement
/// 0 → 01 → 0110 → 01101001 → ...
/// Each digit is count of 1s in binary representation mod 2
pub fn thue_morse(length: usize) -> Vec<u8> {
    if length == 0 {
        return vec![];
    }

    // Generate using bit count parity
    let bits: Vec<u8> = (0..length * 4)
        .map(|n| (n.count_ones() % 2) as u8)
        .collect();

    // Convert 4 bits to base-12
    let mut result = Vec::with_capacity(length);
    for chunk in bits.chunks(4) {
        if result.len() >= length {
            break;
        }
        let val: u8 = chunk.iter().enumerate()
            .map(|(i, &bit)| bit << i)
            .sum();
        result.push(val % 12);
    }

    result.truncate(length);
    result
}

/// Logistic Map: x_{n+1} = r * x_n * (1 - x_n)
///
/// Chaotic for r close to 4. Typical values:
/// - r = 3.99, x0 = 0.5: fully chaotic
/// - r = 3.56995: onset of chaos
/// - r = 3.8284: period-3 window
pub fn logistic_map(r: f64, x0: f64, length: usize) -> Vec<u8> {
    if length == 0 {
        return vec![];
    }

    let mut x = x0;
    let mut result = Vec::with_capacity(length);

    for _ in 0..length {
        x = r * x * (1.0 - x);
        // Map [0, 1] to [0, 11]
        let digit = (x * 11.99).floor() as u8;
        result.push(digit.min(11));
    }

    result
}

/// Collatz sequence (3n+1 problem)
/// Maps each value mod 12
pub fn collatz_sequence(start: u64, length: usize) -> Vec<u8> {
    if length == 0 {
        return vec![];
    }

    let mut n = start;
    let mut result = Vec::with_capacity(length);

    for _ in 0..length {
        result.push((n % 12) as u8);
        if n == 1 {
            n = start; // Loop back to start
        } else if n % 2 == 0 {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    }

    result
}

/// Recaman sequence
/// a(n) = a(n-1) - n if positive and not already in sequence, else a(n-1) + n
pub fn recaman_sequence(length: usize) -> Vec<u8> {
    if length == 0 {
        return vec![];
    }

    let mut seq = vec![0i64];
    let mut seen = std::collections::HashSet::new();
    seen.insert(0i64);

    for n in 1..length {
        let prev = seq[n - 1];
        let back = prev - n as i64;

        let next = if back > 0 && !seen.contains(&back) {
            back
        } else {
            prev + n as i64
        };

        seq.push(next);
        seen.insert(next);
    }

    // Map to base-12
    seq.into_iter()
        .map(|v| (v.unsigned_abs() % 12) as u8)
        .collect()
}

/// Look-and-say sequence (Conway)
/// 1, 11, 21, 1211, 111221, ...
pub fn look_and_say(iterations: u32) -> Vec<u8> {
    let mut s = vec![1u8];

    for _ in 0..iterations {
        let mut next = Vec::with_capacity(s.len() * 2);
        let mut i = 0;

        while i < s.len() {
            let digit = s[i];
            let mut count = 1u8;

            while i + (count as usize) < s.len() && s[i + count as usize] == digit {
                count += 1;
            }

            next.push(count % 12);
            next.push(digit % 12);
            i += count as usize;
        }

        s = next;
    }

    s
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fibonacci_word() {
        let fib = fibonacci_word(100);
        assert_eq!(fib.len(), 100);
        assert!(fib.iter().all(|&d| d < 12));
    }

    #[test]
    fn test_thue_morse() {
        let tm = thue_morse(100);
        assert_eq!(tm.len(), 100);
        assert!(tm.iter().all(|&d| d < 12));
    }

    #[test]
    fn test_logistic_chaotic() {
        let lm = logistic_map(3.99, 0.5, 100);
        assert_eq!(lm.len(), 100);
        assert!(lm.iter().all(|&d| d < 12));

        // Should be "random-looking" - not all same digit
        let unique: std::collections::HashSet<_> = lm.iter().collect();
        assert!(unique.len() > 5);
    }

    #[test]
    fn test_collatz() {
        let col = collatz_sequence(27, 100);
        assert_eq!(col.len(), 100);
        assert!(col.iter().all(|&d| d < 12));
    }

    #[test]
    fn test_recaman() {
        let rec = recaman_sequence(100);
        assert_eq!(rec.len(), 100);
        assert!(rec.iter().all(|&d| d < 12));
    }
}
